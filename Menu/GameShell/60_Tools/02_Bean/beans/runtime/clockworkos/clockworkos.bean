/* Copyright (C) 1991-2017 Free Software Foundation, Inc.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

module libc {

/************************************************************************
    features.h
************************************************************************/

/* These are defined by the user (or the compiler)
   to specify the desired environment */
define {
    _LARGEFILE_SOURCE = 0;
    _LARGEFILE64_SOURCE = 0;
    _FILE_OFFSET_BITS = 32;
    _ATFILE_SOURCE = 1;
    _DEFAULT_SOURCE = 1;
}

define {
#if _LARGEFILE_SOURCE;
    __USE_LARGEFILE = 1;
#endif
#if _LARGEFILE64_SOURCE;
    __USE_LARGEFILE64 = 1;
#endif
#if _FILE_OFFSET_BITS == 64;
    __USE_FILE_OFFSET64 = 1;
#endif
#if _DEFAULT_SOURCE;
    __USE_MISC = 1;
#endif
#if _ATFILE_SOURCE;
    __USE_GNU = 1;
#endif
}

define {
    __USE_POSIX199309 = 1;
    __USE_XOPEN2K = 1;
    __USE_XOPEN2K8 = 1;
    __USE_ISOC99 = 1;
}

/************************************************************************
    bits/wordsize.h
************************************************************************/

define {
    __WORDSIZE = 32;
}

/************************************************************************
    bits/types.h
************************************************************************/

/* Convenience types.  */
typedef __u_char unsigned char;
typedef __u_short unsigned short;
typedef __u_int unsigned int;
typedef __u_long unsigned long;

/* Fixed-size types, underlying types depend on word size and compiler.  */
typedef __int8_t char;
typedef __uint8_t unsigned char;
typedef __int16_t short;
typedef __uint16_t unsigned short;
typedef __int32_t int;
typedef __uint32_t unsigned int;

#if __WORDSIZE == 64;
    typedef __int64_t long;
    typedef __uint64_t unsigned long;
#else
    typedef __int64_t dlong;
    typedef __uint64_t unsigned dlong;
#endif

/* quad_t is also 64 bits.  */
#if __WORDSIZE == 64;
    typedef __quad_t long;
    typedef __u_quad_t unsigned long;
#else
    typedef __quad_t dlong;
    typedef __u_quad_t unsigned dlong;
#endif

/* Largest integral types.  */
#if __WORDSIZE == 64;
    typedef __intmax_t long;
    typedef __uintmax_t unsigned long;
#else
    typedef __intmax_t dlong;
    typedef __uintmax_t unsigned dlong;
#endif

define {
    __S16_TYPE = short;
    __U16_TYPE = unsigned short;
    __S32_TYPE = int;
    __U32_TYPE = unsigned int;
    __SLONGWORD_TYPE = long;
    __ULONGWORD_TYPE = unsigned long;
#if __WORDSIZE == 32;
    __SQUAD_TYPE = __quad_t;
    __UQUAD_TYPE = __u_quad_t;
    __SWORD_TYPE = int;
    __UWORD_TYPE = unsigned int;
    __SLONG32_TYPE = long;
    __ULONG32_TYPE = unsigned long;
    __S64_TYPE = __quad_t;
    __U64_TYPE = __u_quad_t;
#elseif __WORDSIZE == 64;
    __SQUAD_TYPE = long;
    __UQUAD_TYPE = unsigned long;
    __SWORD_TYPE = long;
    __UWORD_TYPE = unsigned long;
    __SLONG32_TYPE = int;
    __ULONG32_TYPE = unsigned int;
    __S64_TYPE = long;
    __U64_TYPE = unsigned long;
#endif
}

/************************************************************************
    bits/typesizes.h
************************************************************************/

/* Type of file system IDs.  */
struct __fsid_t {
    __val(2) int;
}

define {
    __DEV_T_TYPE = __UQUAD_TYPE;
    __UID_T_TYPE = __U32_TYPE;
    __GID_T_TYPE = __U32_TYPE;
    __INO_T_TYPE = __ULONGWORD_TYPE;
    __INO64_T_TYPE = __UQUAD_TYPE;
    __MODE_T_TYPE = __U32_TYPE;
    __NLINK_T_TYPE = __UWORD_TYPE;
    __OFF_T_TYPE = __SLONGWORD_TYPE;
    __OFF64_T_TYPE = __SQUAD_TYPE;
    __PID_T_TYPE = __S32_TYPE;
    __RLIM_T_TYPE = __ULONGWORD_TYPE;
    __RLIM64_T_TYPE = __UQUAD_TYPE;
    __BLKCNT_T_TYPE = __SLONGWORD_TYPE;
    __BLKCNT64_T_TYPE = __SQUAD_TYPE;
    __FSBLKCNT_T_TYPE = __ULONGWORD_TYPE;
    __FSBLKCNT64_T_TYPE = __UQUAD_TYPE;
    __FSFILCNT_T_TYPE = __ULONGWORD_TYPE;
    __FSFILCNT64_T_TYPE = __UQUAD_TYPE;
    __FSWORD_T_TYPE = __SWORD_TYPE;
    __ID_T_TYPE = __U32_TYPE;
    __CLOCK_T_TYPE = __SLONGWORD_TYPE;
    __TIME_T_TYPE = __SLONGWORD_TYPE;
    __USECONDS_T_TYPE = __U32_TYPE;
    __SUSECONDS_T_TYPE = __SLONGWORD_TYPE;
    __DADDR_T_TYPE = __S32_TYPE;
    __KEY_T_TYPE = __S32_TYPE;
    __CLOCKID_T_TYPE = __S32_TYPE;
    __TIMER_T_TYPE = void;
    __BLKSIZE_T_TYPE = __SLONGWORD_TYPE;
    __FSID_T_TYPE = __fsid_t;
    __SSIZE_T_TYPE = __SWORD_TYPE;
    __SYSCALL_SLONG_TYPE = __SLONGWORD_TYPE;
    __SYSCALL_ULONG_TYPE = __ULONGWORD_TYPE;
    __CPU_MASK_TYPE = __ULONGWORD_TYPE;
}

define {
    __FD_SETSIZE = 1024;
}

/************************************************************************
    bits/types.h
************************************************************************/

typedef __dev_t __DEV_T_TYPE;        /* Type of device numbers.  */
typedef __uid_t __UID_T_TYPE;        /* Type of user identifications.  */
typedef __gid_t __GID_T_TYPE;        /* Type of group identifications.  */
typedef __ino_t __INO_T_TYPE;        /* Type of file serial numbers.  */
typedef __ino64_t __INO64_T_TYPE;    /* Type of file serial numbers (LFS).*/
typedef __mode_t __MODE_T_TYPE;      /* Type of file attribute bitmasks.  */
typedef __nlink_t __NLINK_T_TYPE;    /* Type of file link counts.  */
typedef __off_t __OFF_T_TYPE;        /* Type of file sizes and offsets.  */
typedef __off64_t __OFF64_T_TYPE;    /* Type of file sizes and offsets (LFS).  */
typedef __pid_t __PID_T_TYPE;        /* Type of process identifications.  */
typedef __clock_t __CLOCK_T_TYPE;    /* Type of CPU usage counts.  */
typedef __rlim_t __RLIM_T_TYPE;      /* Type for resource measurement.  */
typedef __rlim64_t __RLIM64_T_TYPE;  /* Type for resource measurement (LFS).  */
typedef __id_t __ID_T_TYPE;          /* General type for IDs.  */
typedef __time_t __TIME_T_TYPE;      /* Seconds since the Epoch.  */
typedef __useconds_t __USECONDS_T_TYPE;     /* Count of microseconds.  */
typedef __suseconds_t __SUSECONDS_T_TYPE;   /* Signed count of microseconds.  */

typedef __daddr_t __DADDR_T_TYPE;   /* The type of a disk address.  */
typedef __key_t __KEY_T_TYPE;       /* Type of an IPC key.  */

/* Clock ID used in clock and timer functions.  */
typedef __clockid_t __CLOCKID_T_TYPE;

/* Timer ID returned by `timer_create'.  */
typedef __timer_t __TIMER_T_TYPE;

/* Type to represent block size.  */
typedef __blksize_t __BLKSIZE_T_TYPE;

/* Types from the Large File Support interface.  */

/* Type to count number of disk blocks.  */
typedef __blkcnt_t __BLKCNT_T_TYPE;
typedef __blkcnt64_t __BLKCNT64_T_TYPE;

/* Type to count file system blocks.  */
typedef __fsblkcnt_t __FSBLKCNT_T_TYPE;
typedef __fsblkcnt64_t __FSBLKCNT64_T_TYPE;

/* Type to count file system nodes.  */
typedef __fsfilcnt_t __FSFILCNT_T_TYPE;
typedef __fsfilcnt64_t __FSFILCNT64_T_TYPE;

/* Type of miscellaneous file system fields.  */
typedef __fsword_t __FSWORD_T_TYPE;

typedef __ssize_t __SSIZE_T_TYPE; /* Type of a byte count, or error.  */

/* Signed long type used in system calls.  */
typedef __syscall_slong_t __SYSCALL_SLONG_TYPE;
/* Unsigned long type used in system calls.  */
typedef __syscall_ulong_t __SYSCALL_ULONG_TYPE;

/* These few don't really vary by system, they always correspond
   to one of the other defined types.  */
typedef __loff_t __off64_t; /* Type of file sizes and offsets (LFS).  */
typedef __qaddr_t __quad_t *;
typedef __caddr_t char *;

/* Duplicates info from stdint.h but this is used in unistd.h.  */
typedef __intptr_t __SWORD_TYPE;

/* Duplicate info from sys/socket.h.  */
typedef __socklen_t __U32_TYPE;

/************************************************************************
    types.h
************************************************************************/

#if objectid(__USE_MISC);
    typedef u_char __u_char;
    typedef u_short __u_short;
    typedef u_int __u_int;
    typedef u_long __u_long;
    typedef quad_t __quad_t;
    typedef u_quad_t __u_quad_t;
    typedef fsid_t __fsid_t;
#endif

typedef loff_t __loff_t;

#if !objectid(__USE_FILE_OFFSET64);
    typedef ino_t __ino_t;
#else
    typedef ino_t __ino64_t;
#endif

#if objectid(__USE_LARGEFILE64);
    typedef ino64_t __ino64_t;
#endif

typedef dev_t __dev_t;
typedef gid_t __gid_t;
typedef mode_t __mode_t;
typedef nlink_t __nlink_t;
typedef uid_t __uid_t;

#if !objectid(__USE_FILE_OFFSET64);
    typedef off_t __off_t;
#else
    typedef off_t __off64_t;
#endif

#if objectid(__USE_LARGEFILE64);
    typedef off64_t __off64_t;
#endif

typedef pid_t __pid_t;

#if objectid(__USE_XOPEN) | objectid(__USE_XOPEN2K8);
    typedef id_t __id_t;
#endif

typedef ssize_t __ssize_t;

#if objectid(__USE_MISC);
    typedef daddr_t __daddr_t;
    typedef caddr_t __caddr_t;
#endif

#if objectid(__USE_MISC) | objectid(__USE_XOPEN);
    typedef key_t __key_t;
#endif

#if objectid(__USE_XOPEN) | objectid(__USE_XOPEN2K8);
    // bits/types/clock_t.h
    typedef clock_t __clock_t;
#endif

// bits/types/clockid_t.h
typedef clockid_t __clockid_t;

// bits/types/time_t.h
typedef time_t __time_t;

// bits/types/timer_t.h
typedef timer_t __timer_t;

/************************************************************************
    bits/endian.h
************************************************************************/

/* ARM can be either big or little endian.  */
#if objectid(__ARMEB__);
    define { __BYTE_ORDER = __BIG_ENDIAN }
#else
    define { __BYTE_ORDER = __LITTLE_ENDIAN }
#endif

/************************************************************************
    endian.h
************************************************************************/

define {
    __LITTLE_ENDIAN = 1234;
    __BIG_ENDIAN = 4321;
    __PDP_ENDIAN = 3412;
}

/* Some machines may need to use a different endianness for floating point
   values.  */
define {
    __FLOAT_WORD_ORDER = __BYTE_ORDER;
}

#if objectid(__USE_MISC);
    define {
        LITTLE_ENDIAN = __LITTLE_ENDIAN;
        BIG_ENDIAN = __BIG_ENDIAN;
        PDP_ENDIAN = __PDP_ENDIAN;
        BYTE_ORDER = __BYTE_ORDER;
    }
#endif

/************************************************************************
    unistd.h
************************************************************************/

define {
    STDIN_FILENO = 0;   /* Standard input.  */
    STDOUT_FILENO = 1;  /* Standard output.  */
    STDERR_FILENO = 2;  /* Standard error output.  */
}

/* Values for the second argument to access.
   These may be OR'd together.  */
define {
    R_OK = 4;        /* Test for read permission.  */
    W_OK = 2;        /* Test for write permission.  */
    X_OK = 1;        /* Test for execute permission.  */
    F_OK = 0;        /* Test for existence.  */
}

/* Values for the WHENCE argument to lseek.  */
define {
    SEEK_SET = 0;           /* Seek from beginning of file.  */
    SEEK_CUR = 1;           /* Seek from current position.  */
    SEEK_END = 2;           /* Seek from end of file.  */
    #if objectid(__USE_GNU);
        SEEK_DATA = 3;      /* Seek to next data.  */
        SEEK_HOLE = 4;      /* Seek to next hole.  */
    #endif
}

typedef useconds_t __useconds_t;

/************************************************************************
    bits/confname.h
************************************************************************/

/* Values for the argument to `sysconf'.  */
enum {
    _SC_ARG_MAX,
    _SC_CHILD_MAX,
    _SC_CLK_TCK,
    _SC_NGROUPS_MAX,
    _SC_OPEN_MAX,
    _SC_STREAM_MAX,
    _SC_TZNAME_MAX,
    _SC_JOB_CONTROL,
    _SC_SAVED_IDS,
    _SC_REALTIME_SIGNALS,
    _SC_PRIORITY_SCHEDULING,
    _SC_TIMERS,
    _SC_ASYNCHRONOUS_IO,
    _SC_PRIORITIZED_IO,
    _SC_SYNCHRONIZED_IO,
    _SC_FSYNC,
    _SC_MAPPED_FILES,
    _SC_MEMLOCK,
    _SC_MEMLOCK_RANGE,
    _SC_MEMORY_PROTECTION,
    _SC_MESSAGE_PASSING,
    _SC_SEMAPHORES,
    _SC_SHARED_MEMORY_OBJECTS,
    _SC_AIO_LISTIO_MAX,
    _SC_AIO_MAX,
    _SC_AIO_PRIO_DELTA_MAX,
    _SC_DELAYTIMER_MAX,
    _SC_MQ_OPEN_MAX,
    _SC_MQ_PRIO_MAX,
    _SC_VERSION,
    _SC_PAGESIZE,
    _SC_RTSIG_MAX,
    _SC_SEM_NSEMS_MAX,
    _SC_SEM_VALUE_MAX,
    _SC_SIGQUEUE_MAX,
    _SC_TIMER_MAX,
    /* Values for the argument to `sysconf'
       corresponding to _POSIX2_* symbols.  */
    _SC_BC_BASE_MAX,
    _SC_BC_DIM_MAX,
    _SC_BC_SCALE_MAX,
    _SC_BC_STRING_MAX,
    _SC_COLL_WEIGHTS_MAX,
    _SC_EQUIV_CLASS_MAX,
    _SC_EXPR_NEST_MAX,
    _SC_LINE_MAX,
    _SC_RE_DUP_MAX,
    _SC_CHARCLASS_NAME_MAX,
    _SC_2_VERSION,
    _SC_2_C_BIND,
    _SC_2_C_DEV,
    _SC_2_FORT_DEV,
    _SC_2_FORT_RUN,
    _SC_2_SW_DEV,
    _SC_2_LOCALEDEF,
    _SC_PII,
    _SC_PII_XTI,
    _SC_PII_SOCKET,
    _SC_PII_INTERNET,
    _SC_PII_OSI,
    _SC_POLL,
    _SC_SELECT,
    _SC_UIO_MAXIOV,
    _SC_IOV_MAX = _SC_UIO_MAXIOV,
    _SC_PII_INTERNET_STREAM,
    _SC_PII_INTERNET_DGRAM,
    _SC_PII_OSI_COTS,
    _SC_PII_OSI_CLTS,
    _SC_PII_OSI_M,
    _SC_T_IOV_MAX,
    /* Values according to POSIX 1003.1c (POSIX threads).  */
    _SC_THREADS,
    _SC_THREAD_SAFE_FUNCTIONS,
    _SC_GETGR_R_SIZE_MAX,
    _SC_GETPW_R_SIZE_MAX,
    _SC_LOGIN_NAME_MAX,
    _SC_TTY_NAME_MAX,
    _SC_THREAD_DESTRUCTOR_ITERATIONS,
    _SC_THREAD_KEYS_MAX,
    _SC_THREAD_STACK_MIN,
    _SC_THREAD_THREADS_MAX,
    _SC_THREAD_ATTR_STACKADDR,
    _SC_THREAD_ATTR_STACKSIZE,
    _SC_THREAD_PRIORITY_SCHEDULING,
    _SC_THREAD_PRIO_INHERIT,
    _SC_THREAD_PRIO_PROTECT,
    _SC_THREAD_PROCESS_SHARED,
    _SC_NPROCESSORS_CONF,
    _SC_NPROCESSORS_ONLN,
    _SC_PHYS_PAGES,
    _SC_AVPHYS_PAGES,
    _SC_ATEXIT_MAX,
    _SC_PASS_MAX,
    _SC_XOPEN_VERSION,
    _SC_XOPEN_XCU_VERSION,
    _SC_XOPEN_UNIX,
    _SC_XOPEN_CRYPT,
    _SC_XOPEN_ENH_I18N,
    _SC_XOPEN_SHM,
    _SC_2_CHAR_TERM,
    _SC_2_C_VERSION,
    _SC_2_UPE,
    _SC_XOPEN_XPG2,
    _SC_XOPEN_XPG3,
    _SC_XOPEN_XPG4,
    _SC_CHAR_BIT,
    _SC_CHAR_MAX,
    _SC_CHAR_MIN,
    _SC_INT_MAX,
    _SC_INT_MIN,
    _SC_LONG_BIT,
    _SC_WORD_BIT,
    _SC_MB_LEN_MAX,
    _SC_NZERO,
    _SC_SSIZE_MAX,
    _SC_SCHAR_MAX,
    _SC_SCHAR_MIN,
    _SC_SHRT_MAX,
    _SC_SHRT_MIN,
    _SC_UCHAR_MAX,
    _SC_UINT_MAX,
    _SC_ULONG_MAX,
    _SC_USHRT_MAX,
    _SC_NL_ARGMAX,
    _SC_NL_LANGMAX,
    _SC_NL_MSGMAX,
    _SC_NL_NMAX,
    _SC_NL_SETMAX,
    _SC_NL_TEXTMAX,
    _SC_XBS5_ILP32_OFF32,
    _SC_XBS5_ILP32_OFFBIG,
    _SC_XBS5_LP64_OFF64,
    _SC_XBS5_LPBIG_OFFBIG,
    _SC_XOPEN_LEGACY,
    _SC_XOPEN_REALTIME,
    _SC_XOPEN_REALTIME_THREADS,
    _SC_ADVISORY_INFO,
    _SC_BARRIERS,
    _SC_BASE,
    _SC_C_LANG_SUPPORT,
    _SC_C_LANG_SUPPORT_R,
    _SC_CLOCK_SELECTION,
    _SC_CPUTIME,
    _SC_THREAD_CPUTIME,
    _SC_DEVICE_IO,
    _SC_DEVICE_SPECIFIC,
    _SC_DEVICE_SPECIFIC_R,
    _SC_FD_MGMT,
    _SC_FIFO,
    _SC_PIPE,
    _SC_FILE_ATTRIBUTES,
    _SC_FILE_LOCKING,
    _SC_FILE_SYSTEM,
    _SC_MONOTONIC_CLOCK,
    _SC_MULTI_PROCESS,
    _SC_SINGLE_PROCESS,
    _SC_NETWORKING,
    _SC_READER_WRITER_LOCKS,
    _SC_SPIN_LOCKS,
    _SC_REGEXP,
    _SC_REGEX_VERSION,
    _SC_SHELL,
    _SC_SIGNALS,
    _SC_SPAWN,
    _SC_SPORADIC_SERVER,
    _SC_THREAD_SPORADIC_SERVER,
    _SC_SYSTEM_DATABASE,
    _SC_SYSTEM_DATABASE_R,
    _SC_TIMEOUTS,
    _SC_TYPED_MEMORY_OBJECTS,
    _SC_USER_GROUPS,
    _SC_USER_GROUPS_R,
    _SC_2_PBS,
    _SC_2_PBS_ACCOUNTING,
    _SC_2_PBS_LOCATE,
    _SC_2_PBS_MESSAGE,
    _SC_2_PBS_TRACK,
    _SC_SYMLOOP_MAX,
    _SC_STREAMS,
    _SC_2_PBS_CHECKPOINT,
    _SC_V6_ILP32_OFF32,
    _SC_V6_ILP32_OFFBIG,
    _SC_V6_LP64_OFF64,
    _SC_V6_LPBIG_OFFBIG,
    _SC_HOST_NAME_MAX,
    _SC_TRACE,
    _SC_TRACE_EVENT_FILTER,
    _SC_TRACE_INHERIT,
    _SC_TRACE_LOG,
    _SC_LEVEL1_ICACHE_SIZE,
    _SC_LEVEL1_ICACHE_ASSOC,
    _SC_LEVEL1_ICACHE_LINESIZE,
    _SC_LEVEL1_DCACHE_SIZE,
    _SC_LEVEL1_DCACHE_ASSOC,
    _SC_LEVEL1_DCACHE_LINESIZE,
    _SC_LEVEL2_CACHE_SIZE,
    _SC_LEVEL2_CACHE_ASSOC,
    _SC_LEVEL2_CACHE_LINESIZE,
    _SC_LEVEL3_CACHE_SIZE,
    _SC_LEVEL3_CACHE_ASSOC,
    _SC_LEVEL3_CACHE_LINESIZE,
    _SC_LEVEL4_CACHE_SIZE,
    _SC_LEVEL4_CACHE_ASSOC,
    _SC_LEVEL4_CACHE_LINESIZE,
    /* Leave room here, maybe we need a few more cache levels some day.  */
    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,
    _SC_RAW_SOCKETS,
    _SC_V7_ILP32_OFF32,
    _SC_V7_ILP32_OFFBIG,
    _SC_V7_LP64_OFF64,
    _SC_V7_LPBIG_OFFBIG,
    _SC_SS_REPL_MAX,
    _SC_TRACE_EVENT_NAME_MAX,
    _SC_TRACE_NAME_MAX,
    _SC_TRACE_SYS_MAX,
    _SC_TRACE_USER_EVENT_MAX,
    _SC_XOPEN_STREAMS,
    _SC_THREAD_ROBUST_PRIO_INHERIT,
    _SC_THREAD_ROBUST_PRIO_PROTECT
}

/************************************************************************
    limits.h
************************************************************************/

define {
    NR_OPEN = 1024;
    NGROUPS_MAX = 65536;    /* supplemental group IDs are available */
    ARG_MAX = 131072;       /* # bytes of args + environ for exec() */
    LINK_MAX = 127;         /* # links a file may have */
    MAX_CANON = 255;        /* size of the canonical input queue */
    MAX_INPUT = 255;        /* size of the type-ahead buffer */
    NAME_MAX = 255;         /* # chars in a file name */
    PATH_MAX = 4096;        /* # chars in a path name including nul */
    PIPE_BUF = 4096;        /* # bytes in atomic write to a pipe */
    XATTR_NAME_MAX = 255;   /* # chars in an extended attribute name */
    XATTR_SIZE_MAX = 65536; /* size of an extended attribute value (64k) */
    XATTR_LIST_MAX = 65536; /* size of extended attribute namelist (64k) */
    RTSIG_MAX = 32;
}

/************************************************************************
    errno.h
************************************************************************/

define {
    EPERM = 1;      /* Operation not permitted */
    ENOENT = 2;     /* No such file or directory */
    ESRCH = 3;      /* No such process */
    EINTR = 4;      /* Interrupted system call */
    EIO = 5;        /* I/O error */
    ENXIO = 6;      /* No such device or address */
    E2BIG = 7;      /* Argument list too long */
    ENOEXEC = 8;    /* Exec format error */
    EBADF = 9;      /* Bad file number */
    ECHILD = 10;    /* No child processes */
    EAGAIN = 11;    /* Try again */
    ENOMEM = 12;    /* Out of memory */
    EACCES = 13;    /* Permission denied */
    EFAULT = 14;    /* Bad address */
    ENOTBLK = 15;   /* Block device required */
    EBUSY = 16;     /* Device or resource busy */
    EEXIST = 17;    /* File exists */
    EXDEV = 18;     /* Cross-device link */
    ENODEV = 19;    /* No such device */
    ENOTDIR = 20;   /* Not a directory */
    EISDIR = 21;    /* Is a directory */
    EINVAL = 22;    /* Invalid argument */
    ENFILE = 23;    /* File table overflow */
    EMFILE = 24;    /* Too many open files */
    ENOTTY = 25;    /* Not a typewriter */
    ETXTBSY = 26;   /* Text file busy */
    EFBIG = 27;     /* File too large */
    ENOSPC = 28;    /* No space left on device */
    ESPIPE = 29;    /* Illegal seek */
    EROFS = 30;     /* Read-only file system */
    EMLINK = 31;    /* Too many links */
    EPIPE = 32;     /* Broken pipe */
    EDOM = 33;      /* Math argument out of domain of func */
    ERANGE = 34;    /* Math result not representable */
}

define {
    EDEADLK = 35;           /* Resource deadlock would occur */
    ENAMETOOLONG = 36;      /* File name too long */
    ENOLCK = 37;            /* No record locks available */
    /*
    * This error code is special: arch syscall entry code will return
    * -ENOSYS if users try to call a syscall that doesn't exist.  To keep
    * failures of syscalls that really do exist distinguishable from
    * failures due to attempts to use a nonexistent syscall, syscall
    * implementations should refrain from returning -ENOSYS.
    */
    ENOSYS = 38;            /* Invalid system call number */
    ENOTEMPTY = 39;         /* Directory not empty */
    ELOOP = 40;             /* Too many symbolic links encountered */
    EWOULDBLOCK = EAGAIN;   /* Operation would block */
    ENOMSG = 42;            /* No message of desired type */
    EIDRM = 43;             /* Identifier removed */
    ECHRNG = 44;            /* Channel number out of range */
    EL2NSYNC = 45;          /* Level 2 not synchronized */
    EL3HLT = 46;            /* Level 3 halted */
    EL3RST = 47;            /* Level 3 reset */
    ELNRNG = 48;            /* Link number out of range */
    EUNATCH = 49;           /* Protocol driver not attached */
    ENOCSI = 50;            /* No CSI structure available */
    EL2HLT = 51;            /* Level 2 halted */
    EBADE = 52;             /* Invalid exchange */
    EBADR = 53;             /* Invalid request descriptor */
    EXFULL = 54;            /* Exchange full */
    ENOANO = 55;            /* No anode */
    EBADRQC = 56;           /* Invalid request code */
    EBADSLT = 57;           /* Invalid slot */
    EDEADLOCK = EDEADLK;
    EBFONT = 59;            /* Bad font file format */
    ENOSTR = 60;            /* Device not a stream */
    ENODATA = 61;           /* No data available */
    ETIME = 62;             /* Timer expired */
    ENOSR = 63;             /* Out of streams resources */
    ENONET = 64;            /* Machine is not on the network */
    ENOPKG = 65;            /* Package not installed */
    EREMOTE = 66;           /* Object is remote */
    ENOLINK = 67;           /* Link has been severed */
    EADV = 68;              /* Advertise error */
    ESRMNT = 69;            /* Srmount error */
    ECOMM = 70;             /* Communication error on send */
    EPROTO = 71;            /* Protocol error */
    EMULTIHOP = 72;         /* Multihop attempted */
    EDOTDOT = 73;           /* RFS specific error */
    EBADMSG = 74;           /* Not a data message */
    EOVERFLOW = 75;         /* Value too large for defined data type */
    ENOTUNIQ = 76;          /* Name not unique on network */
    EBADFD = 77;            /* File descriptor in bad state */
    EREMCHG = 78;           /* Remote address changed */
    ELIBACC = 79;           /* Can not access a needed shared library */
    ELIBBAD = 80;           /* Accessing a corrupted shared library */
    ELIBSCN = 81;           /* .lib section in a.out corrupted */
    ELIBMAX = 82;           /* Attempting to link in too many shared libraries */
    ELIBEXEC = 83;          /* Cannot exec a shared library directly */
    EILSEQ = 84;            /* Illegal byte sequence */
    ERESTART = 85;          /* Interrupted system call should be restarted */
    ESTRPIPE = 86;          /* Streams pipe error */
    EUSERS = 87;            /* Too many users */
    ENOTSOCK = 88;          /* Socket operation on non-socket */
    EDESTADDRREQ = 89;      /* Destination address required */
    EMSGSIZE = 90;          /* Message too long */
    EPROTOTYPE = 91;        /* Protocol wrong type for socket */
    ENOPROTOOPT = 92;       /* Protocol not available */
    EPROTONOSUPPORT = 93;   /* Protocol not supported */
    ESOCKTNOSUPPORT = 94;   /* Socket type not supported */
    EOPNOTSUPP = 95;        /* Operation not supported on transport endpoint */
    EPFNOSUPPORT = 96;      /* Protocol family not supported */
    EAFNOSUPPORT = 97;      /* Address family not supported by protocol */
    EADDRINUSE = 98;        /* Address already in use */
    EADDRNOTAVAIL = 99;     /* Cannot assign requested address */
    ENETDOWN = 100;         /* Network is down */
    ENETUNREACH = 101;      /* Network is unreachable */
    ENETRESET = 102;        /* Network dropped connection because of reset */
    ECONNABORTED = 103;     /* Software caused connection abort */
    ECONNRESET = 104;       /* Connection reset by peer */
    ENOBUFS = 105;          /* No buffer space available */
    EISCONN = 106;          /* Transport endpoint is already connected */
    ENOTCONN = 107;         /* Transport endpoint is not connected */
    ESHUTDOWN = 108;        /* Cannot send after transport endpoint shutdown */
    ETOOMANYREFS = 109;     /* Too many references: cannot splice */
    ETIMEDOUT = 110;        /* Connection timed out */
    ECONNREFUSED = 111;     /* Connection refused */
    EHOSTDOWN = 112;        /* Host is down */
    EHOSTUNREACH = 113;     /* No route to host */
    EALREADY = 114;         /* Operation already in progress */
    EINPROGRESS = 115;      /* Operation now in progress */
    ESTALE = 116;           /* Stale file handle */
    EUCLEAN = 117;          /* Structure needs cleaning */
    ENOTNAM = 118;          /* Not a XENIX named type file */
    ENAVAIL = 119;          /* No XENIX semaphores available */
    EISNAM = 120;           /* Is a named type file */
    EREMOTEIO = 121;        /* Remote I/O error */
    EDQUOT = 122;           /* Quota exceeded */
    ENOMEDIUM = 123;        /* No medium found */
    EMEDIUMTYPE = 124;      /* Wrong medium type */
    ECANCELED = 125;        /* Operation Canceled */
    ENOKEY = 126;           /* Required key not available */
    EKEYEXPIRED = 127;      /* Key has expired */
    EKEYREVOKED = 128;      /* Key has been revoked */
    EKEYREJECTED = 129;     /* Key was rejected by service */
    /* for robust mutexes */
    EOWNERDEAD = 130;       /* Owner died */
    ENOTRECOVERABLE = 131;  /* State not recoverable */
    ERFKILL = 132;          /* Operation not possible due to RF-kill */
    EHWPOISON = 133;        /* Memory page has hardware error */
}

/************************************************************************
    bits/types/struct_osockaddr.h
************************************************************************/

struct struct_osockaddr {
    sa_family unsigned short;
    sa_data(14) unsigned char;
}

/************************************************************************
    bits/types/struct_timespec.h
************************************************************************/

struct struct_timespec {
    tv_sec __time_t;            /* Seconds.  */
    tv_nsec __syscall_slong_t;  /* Nanoseconds.  */
}

/************************************************************************
    bits/types/struct_timeval.h
************************************************************************/

struct struct_timeval {
    tv_sec __time_t;        /* Seconds.  */
    tv_usec __suseconds_t;  /* Microseconds.  */
}

/************************************************************************
    bits/types/struct_tm.h
************************************************************************/

struct struct_tm {
    tm_sec int;             /* Seconds.     [0-60] (1 leap second) */
    tm_min int;             /* Minutes.     [0-59] */
    tm_hour int;            /* Hours.       [0-23] */
    tm_mday int;            /* Day.         [1-31] */
    tm_mon int;             /* Month.       [0-11] */
    tm_year int;            /* Year - 1900.  */
    tm_wday int;            /* Day of week. [0-6] */
    tm_yday int;            /* Days in year.[0-365]    */
    tm_isdst int;           /* DST.         [-1/0/1]*/
    #if objectid(__USE_MISC);
        tm_gmtoff long;     /* Seconds east of UTC.  */
        tm_zone. char;      /* Timezone abbreviation.  */
    #else
        __tm_gmtoff long;   /* Seconds east of UTC.  */
        __tm_zone. char;    /* Timezone abbreviation.  */
    #endif
}

/************************************************************************
    bits/stat.h
************************************************************************/

struct struct_stat {
    st_dev __dev_t;             /* Device.  */
    __pad1 unsigned short;
#if !objectid(__USE_FILE_OFFSET64);
    st_ino __ino_t;             /* File serial number.    */
#else
    __st_ino __ino_t;           /* 32bit file serial number.    */
#endif
    st_mode __mode_t;           /* File mode.  */
    st_nlink __nlink_t;         /* Link count.  */
    st_uid __uid_t;             /* User ID of the file's owner.    */
    st_gid __gid_t;             /* Group ID of the file's group.*/
    st_rdev __dev_t;            /* Device number, if device.  */
    __pad2 unsigned short;
#if !objectid(__USE_FILE_OFFSET64);
    st_size __off_t;            /* Size of file, in bytes.  */
#else
    st_size __off64_t;          /* Size of file, in bytes.  */
#endif
    st_blksize __blksize_t;     /* Optimal block size for I/O.  */
#if !objectid(__USE_FILE_OFFSET64);
    st_blocks __blkcnt_t;       /* Number 512-byte blocks allocated. */
#else
    st_blocks __blkcnt64_t;     /* Number 512-byte blocks allocated. */
#endif
#if objectid(__USE_XOPEN2K8);
    /* Nanosecond resolution timestamps are stored in a format
       equivalent to 'struct timespec'.  This is the type used
       whenever possible but the Unix namespace rules do not allow the
       identifier 'timespec' to appear in the <sys/stat.h> header.
       Therefore we have to handle the use of this header in strictly
       standard-compliant sources special.  */
    st_atim struct_timespec;        /* Time of last access.  */
    st_mtim struct_timespec;        /* Time of last modification.  */
    st_ctim struct_timespec;        /* Time of last status change.  */
// #define st_atime st_atim.tv_sec  /* Backward compatibility.  */
// #define st_mtime st_mtim.tv_sec
// #define st_ctime st_ctim.tv_sec
#else
    st_atime __time_t;              /* Time of last access.  */
    st_atimensec unsigned long;     /* Nscecs of last access.  */
    st_mtime __time_t;              /* Time of last modification.  */
    st_mtimensec unsigned long;     /* Nsecs of last modification.  */
    st_ctime __time_t;              /* Time of last status change.  */
    st_ctimensec unsigned long;     /* Nsecs of last status change.  */
#endif
#if !objectid(__USE_FILE_OFFSET64);
    __glibc_reserved4 unsigned long;
    __glibc_reserved5 unsigned long;
#else
    st_ino __ino64_t;               /* File serial number.    */
#endif
}

#if objectid(__USE_LARGEFILE64);
    struct struct_stat64 {
        st_dev __dev_t;                 /* Device.  */
        __pad1 unsigned int;
        __st_ino __ino_t;               /* 32bit file serial number.    */
        st_mode __mode_t;               /* File mode.  */
        st_nlink __nlink_t;             /* Link count.  */
        st_uid __uid_t;                 /* User ID of the file's owner.    */
        st_gid __gid_t;                 /* Group ID of the file's group.*/
        st_rdev __dev_t;                /* Device number, if device.  */
        __pad2 unsigned int;
        st_size __off64_t;              /* Size of file, in bytes.  */
        st_blksize __blksize_t;         /* Optimal block size for I/O.  */
        st_blocks __blkcnt64_t;         /* Number 512-byte blocks allocated. */
    #if objectid(__USE_XOPEN2K8);
        /* Nanosecond resolution timestamps are stored in a format
        equivalent to 'struct timespec'.  This is the type used
        whenever possible but the Unix namespace rules do not allow the
        identifier 'timespec' to appear in the <sys/stat.h> header.
        Therefore we have to handle the use of this header in strictly
        standard-compliant sources special.  */
        st_atim struct_timespec;        /* Time of last access.  */
        st_mtim struct_timespec;        /* Time of last modification.  */
        st_ctim struct_timespec;        /* Time of last status change.  */
    #else
        st_atime __time_t;              /* Time of last access.  */
        st_atimensec unsigned long;     /* Nscecs of last access.  */
        st_mtime __time_t;              /* Time of last modification.  */
        st_mtimensec unsigned long;     /* Nsecs of last modification.  */
        st_ctime __time_t;              /* Time of last status change.  */
        st_ctimensec unsigned long;     /* Nsecs of last status change.  */
    #endif
        st_ino __ino64_t;               /* File serial number.        */
    }
#endif

/* Tell code we have these members.  */
define {
    _STATBUF_ST_BLKSIZE = 1;
    _STATBUF_ST_RDEV = 1;
    /* Nanosecond resolution time values are supported.  */
    _STATBUF_ST_NSEC = 1;
}

/* Encoding of the file mode.  */
define {
    __S_IFMT = 0170000;     /* These bits determine file type.  */
    /* File types.  */
    __S_IFDIR = 0040000;    /* Directory.  */
    __S_IFCHR = 0020000;    /* Character device.  */
    __S_IFBLK = 0060000;    /* Block device.  */
    __S_IFREG = 0100000;    /* Regular file.  */
    __S_IFIFO = 0010000;    /* FIFO.  */
    __S_IFLNK = 0120000;    /* Symbolic link.  */
    __S_IFSOCK = 0140000;   /* Socket.  */
    /* Protection bits.  */
    __S_ISUID = 04000;      /* Set user ID on execution.  */
    __S_ISGID = 02000;      /* Set group ID on execution.  */
    __S_ISVTX = 01000;      /* Save swapped text after use (sticky).  */
    __S_IREAD = 0400;       /* Read by owner.  */
    __S_IWRITE = 0200;      /* Write by owner.  */
    __S_IEXEC = 0100;       /* Execute by owner.  */
}

#if objectid(__USE_ATFILE);
    define {
        UTIME_NOW = ((long(1) << 30) - long(1));
        UTIME_OMIT = ((long(1) << 30) - long(2));
    }
#endif

/************************************************************************
    sys/stat.h
************************************************************************/

inline __S_ISTYPE(mode mode_t, mask mode_t) int {
    return (mode & __S_IFMT) == mask;
}

inline S_ISDIR(mode mode_t) int {
    return __S_ISTYPE(mode, __S_IFDIR);
}
inline S_ISCHR(mode mode_t) int {
    return __S_ISTYPE(mode, __S_IFCHR);
}
inline S_ISBLK(mode mode_t) int {
    return __S_ISTYPE(mode, __S_IFBLK);
}
inline S_ISREG(mode mode_t) int {
    return __S_ISTYPE(mode, __S_IFREG);
}
inline S_ISFIFO(mode mode_t) int {
    return __S_ISTYPE(mode, __S_IFIFO);
}
inline S_ISLNK(mode mode_t) int {
    return __S_ISTYPE(mode, __S_IFLNK);
}

/************************************************************************
    fcntl.h
************************************************************************/

#if objectid(__USE_XOPEN) | objectid(__USE_XOPEN2K8);
    define {
        S_IFMT = __S_IFMT;
        S_IFDIR = __S_IFDIR;
        S_IFCHR = __S_IFCHR;
        S_IFBLK = __S_IFBLK;
        S_IFREG = __S_IFREG;
        #if objectid(__S_IFIFO);
            S_IFIFO = __S_IFIFO;
        #endif
        #if objectid(__S_IFLNK);
            S_IFLNK = __S_IFLNK;
        #endif
        #if objectid(__USE_UNIX98) | objectid(__USE_XOPEN2K8);
            #if objectid(__S_IFSOCK);
                S_IFSOCK = __S_IFSOCK;
            #endif
        #endif
        /* Protection bits.  */
        S_ISUID = __S_ISUID;       /* Set user ID on execution.  */
        S_ISGID = __S_ISGID;       /* Set group ID on execution.  */
        #if objectid(__USE_MISC) | objectid(__USE_XOPEN);
            S_ISVTX = __S_ISVTX;
        #endif
        S_IRUSR = __S_IREAD;       /* Read by owner.  */
        S_IWUSR = __S_IWRITE;      /* Write by owner.  */
        S_IXUSR = __S_IEXEC;       /* Execute by owner.  */
        /* Read, write, and execute by owner.  */
        S_IRWXU = (__S_IREAD|__S_IWRITE|__S_IEXEC);
        S_IRGRP = (S_IRUSR >> 3);  /* Read by group.  */
        S_IWGRP = (S_IWUSR >> 3);  /* Write by group.  */
        S_IXGRP = (S_IXUSR >> 3);  /* Execute by group.  */
        /* Read, write, and execute by group.  */
        S_IRWXG = (S_IRWXU >> 3);
        S_IROTH = (S_IRGRP >> 3);  /* Read by others.  */
        S_IWOTH = (S_IWGRP >> 3);  /* Write by others.  */
        S_IXOTH = (S_IXGRP >> 3);  /* Execute by others.  */
        /* Read, write, and execute by others.  */
        S_IRWXO = (S_IRWXG >> 3);
    }
#endif

/* The constants AT_REMOVEDIR and AT_EACCESS have the same value.  AT_EASSESS
   is meaningful only to faccessat, while AT_REMOVEDIR is meaningful only to
   unlinkat.  The two functions do completely different things and therefore,
   the flags can be allowed to overlap.  For example, passing AT_REMOVEDIR to
   faccessat would be undefined behavior and thus treating it equivalent to
   AT_EACCESS is valid undefined behavior.  */
#if objectid(__USE_ATFILE);
    define {
        AT_FDCWD = -100;                /* Special value used to indicate
                                            the *at functions should use the
                                            current working directory. */
        AT_SYMLINK_NOFOLLOW = 0x100;    /* Do not follow symbolic links.  */
        AT_REMOVEDIR = 0x200;           /* Remove directory instead of unlinking file.  */
        AT_SYMLINK_FOLLOW = 0x400;      /* Follow symbolic links.  */
    #if objectid(__USE_GNU);
        AT_NO_AUTOMOUNT = 0x800;        /* Suppress terminal automount traversal.  */
        AT_EMPTY_PATH = 0x1000;         /* Allow empty relative pathname.  */
    #endif
        AT_EACCESS= 0x200;              /* Test access permitted for
                                            effective IDs, not real IDs.  */
    }
#endif

define {
    F_ULOCK = 0;    /* Unlock a previously locked region.  */
    F_LOCK = 1;     /* Lock a region for exclusive use.  */
    F_TLOCK = 2;    /* Test and lock a region for exclusive use.  */
    F_TEST = 3;     /* Test a region for other processes locks.  */
}

/************************************************************************
    bits/fcntl-linux.h
************************************************************************/

/* open/fcntl.  */
define {
    O_ACCMODE = 0003;
    O_RDONLY = 00;
    O_WRONLY = 01;
    O_RDWR = 02;
    O_CREAT = 0100;     /* Not fcntl.  */
    O_EXCL = 0200;      /* Not fcntl.  */
    O_NOCTTY = 0400;    /* Not fcntl.  */
    O_TRUNC = 01000;    /* Not fcntl.  */
    O_APPEND = 02000;
    O_NONBLOCK = 04000;
    O_NDELAY = O_NONBLOCK;
    O_SYNC = 04010000;
    O_FSYNC = O_SYNC;
    O_ASYNC = 020000;
    __O_LARGEFILE = 0100000;
    __O_DIRECTORY = 0200000;
    __O_NOFOLLOW = 0400000;
    __O_CLOEXEC = 02000000;
    __O_DIRECT = 040000;
    __O_NOATIME = 01000000;
    __O_PATH = 010000000;
    __O_DSYNC = 010000;
    __O_TMPFILE = (020000000 | __O_DIRECTORY);
}

define {
#if !objectid(__USE_FILE_OFFSET64);
    F_GETLK = 5;            /* Get record locking info.  */
    F_SETLK = 6;            /* Set record locking info (non-blocking).  */
    F_SETLKW = 7;           /* Set record locking info (blocking).    */
#else
    F_GETLK = F_GETLK64;    /* Get record locking info.    */
    F_SETLK = F_SETLK64;    /* Set record locking info (non-blocking).*/
    F_SETLKW = F_SETLKW64;  /* Set record locking info (blocking).  */
#endif
#if !objectid(F_GETLK64);
    F_GETLK64 = 12;         /* Get record locking info.  */
    F_SETLK64 = 13;         /* Set record locking info (non-blocking).  */
    F_SETLKW64 = 14;        /* Set record locking info (blocking).    */
#endif
/* open file description locks.

   Usually record locks held by a process are released on *any* close and are
   not inherited across a fork.

   These cmd values will set locks that conflict with process-associated record
   locks, but are "owned" by the opened file description, not the process.
   This means that they are inherited across fork or clone with CLONE_FILES
   like BSD (flock) locks, and they are only released automatically when the
   last reference to the the file description against which they were acquired
   is put. */
#if objectid(__USE_GNU);
    F_OFD_GETLK = 36;
    F_OFD_SETLK = 37;
    F_OFD_SETLKW = 38;
#endif
}

define {
    #if objectid(__USE_LARGEFILE64);
        O_LARGEFILE = __O_LARGEFILE;
    #endif
    #if objectid(__USE_XOPEN2K8);
        O_DIRECTORY = __O_DIRECTORY;    /* Must be a directory.     */
        O_NOFOLLOW = __O_NOFOLLOW;      /* Do not follow links.     */
        O_CLOEXEC = __O_CLOEXEC;        /* Set close_on_exec.  */
    #endif
    #if objectid(__USE_GNU);
        O_DIRECT = __O_DIRECT;          /* Direct disk access.    */
        O_NOATIME = __O_NOATIME;        /* Do not set atime.  */
        O_PATH = __O_PATH;              /* Resolve pathname but do not open file.  */
        O_TMPFILE = __O_TMPFILE;        /* Atomically create nameless file.  */
    #endif
    /* For now, Linux has no separate synchronicitiy options for read
        operations.  We define O_RSYNC therefore as the same as O_SYNC
        since this is a superset.  */
    #if objectid(__USE_POSIX199309) | objectid(__USE_UNIX98);
        O_DSYNC = __O_DSYNC;            /* Synchronize data.  */
        #if objectid(__O_RSYNC);
            O_RSYNC = __O_RSYNC;        /* Synchronize read operations.     */
        #else
            O_RSYNC = O_SYNC;           /* Synchronize read operations.     */
        #endif
    #endif
}

/* Values for the second argument to `fcntl'.  */
define {
    F_DUPFD = 0;    /* Duplicate file descriptor.  */
    F_GETFD = 1;    /* Get file descriptor flags.  */
    F_SETFD = 2;    /* Set file descriptor flags.  */
    F_GETFL = 3;    /* Get file status flags.  */
    F_SETFL = 4;    /* Set file status flags.  */
#if !objectid(__F_SETOWN);
    __F_SETOWN = 8;
    __F_GETOWN = 9;
#endif
#if objectid(__USE_UNIX98) | objectid(__USE_XOPEN2K8);
    F_SETOWN = __F_SETOWN; /* Get owner (process receiving SIGIO).  */
    F_GETOWN = __F_GETOWN; /* Set owner (process receiving SIGIO).  */
#endif
#if !objectid(__F_SETSIG);
    __F_SETSIG = 10;    /* Set number of signal to be sent.  */
    __F_GETSIG = 11;    /* Get number of signal to be sent.  */
#endif
#if !objectid(__F_SETOWN_EX);
    __F_SETOWN_EX = 15;    /* Get owner (thread receiving SIGIO).  */
    __F_GETOWN_EX = 16;    /* Set owner (thread receiving SIGIO).  */
#endif
#if objectid(__USE_GNU);
    F_SETSIG = __F_SETSIG;          /* Set number of signal to be sent.  */
    F_GETSIG = __F_GETSIG;          /* Get number of signal to be sent.  */
    F_SETOWN_EX = __F_SETOWN_EX;    /* Get owner (thread receiving SIGIO).  */
    F_GETOWN_EX = __F_GETOWN_EX;    /* Set owner (thread receiving SIGIO).  */
#endif
#if objectid(__USE_GNU);
    F_SETLEASE = 1024;      /* Set a lease.     */
    F_GETLEASE = 1025;      /* Enquire what lease is active.  */
    F_NOTIFY = 1026;        /* Request notifications on a directory.  */
    F_SETPIPE_SZ = 1031;    /* Set pipe page size array.  */
    F_GETPIPE_SZ = 1032;    /* Set pipe page size array.  */
#endif
#if objectid(__USE_XOPEN2K8);
    F_DUPFD_CLOEXEC = 1030; /* Duplicate file descriptor with close-on-exit set.  */
#endif
    /* For F_[GET|SET]FD.  */
    FD_CLOEXEC = 1;         /* Actually anything with low bit set goes */
#if !objectid(F_RDLCK);
    /* For posix fcntl() and `l_type' field of a `struct flock' for lockf().  */
    F_RDLCK = 0;            /* Read lock.  */
    F_WRLCK = 1;            /* Write lock.    */
    F_UNLCK = 2;            /* Remove lock.     */
#endif
}

// asm-generic/fcntl.h
struct struct_flock {
    l_type short;
    l_whence short;
    l_start off_t;      // __kernel_off_t
    l_len off_t;        // __kernel_off_t
    l_pid pid_t;        // __kernel_pid_t
}

/************************************************************************
    bits/dirent.h
************************************************************************/

struct struct_dirent {
#if !objectid(__USE_FILE_OFFSET64);
    d_ino __ino_t;      // d_fileno
    d_off __off_t;
#else
    d_ino __ino64_t;    // d_fileno
    d_off __off64_t;
#endif
    d_reclen unsigned short;
    d_type unsigned char;
    d_name(256) char;   /* We must not include limits.h! */
}

#if objectid(__USE_LARGEFILE64);
    struct struct_dirent64 {
        d_ino __ino64_t;    // d_fileno
        d_off __off64_t;
        d_reclen unsigned short;
        d_type unsigned char;
        d_name(256) char;   /* We must not include limits.h! */
    };
#endif

define {
    _DIRENT_HAVE_D_RECLEN = 1;
    _DIRENT_HAVE_D_OFF = 1;
    _DIRENT_HAVE_D_TYPE = 1;
}

/************************************************************************
    dirent.h
************************************************************************/

#if objectid(__USE_MISC);
    /* File types for `d_type'.  */
    enum {
        DT_UNKNOWN = 0,
        DT_FIFO = 1,
        DT_CHR = 2,
        DT_DIR = 4,
        DT_BLK = 6,
        DT_REG = 8,
        DT_LNK = 10,
        DT_SOCK = 12,
        DT_WHT = 14
    }
    /* Convert between stat structure types and directory types.  */
    inline IFTODT(mode mode_t) int {
        return (mode & 0170000) >> 12;
    }
    inline DTTOIF(dirtype int) int {
        return dirtype << 12;
    }
#endif

define {
    MAXNAMLEN = NAME_MAX;
}

/************************************************************************
    stddef.h (custom)
************************************************************************/

typedef size_t unsigned ssize_t;

define {
    NULL = void(0);
}

/************************************************************************
    stdio.h
************************************************************************/

/* End of file character.
   Some things throughout the library rely on this being -1.  */
define {
    EOF = (-1);
}

// stdio_lim.h
define {
    TMP_MAX = 238328;
    FILENAME_MAX = 4096;
}

/************************************************************************
    stdlib.h
************************************************************************/

/* The largest number rand will return (same as INT_MAX).  */
define {
    RAND_MAX = 2147483647;
}

/* We define these the same for all machines.
   Changes from this to the outside world should be done in `_exit'.  */
define {
    EXIT_FAILURE = 1;    /* Failing exit status.  */
    EXIT_SUCCESS = 0;    /* Successful exit status.  */
}

/************************************************************************
    time.h
************************************************************************/

/* ISO/IEC 9899:1999 7.23.1: Components of time
   The macro `CLOCKS_PER_SEC' is an expression with type `clock_t' that is
   the number per second of the value returned by the `clock' function.  */
/* CAE XSH, Issue 4, Version 2: <time.h>
   The value of CLOCKS_PER_SEC is required to be 1 million on all
   XSI-conformant systems. */
define {
    CLOCKS_PER_SEC = __clock_t(1000000);
}

#if objectid(__USE_POSIX199309);
    define {
        /* Identifier for system-wide realtime clock.  */
        CLOCK_REALTIME = 0;
        /* Monotonic system-wide clock.  */
        CLOCK_MONOTONIC = 1;
        /* High-resolution timer from the CPU.  */
        CLOCK_PROCESS_CPUTIME_ID = 2;
        /* Thread-specific CPU-time clock.  */
        CLOCK_THREAD_CPUTIME_ID = 3;
        /* Monotonic system-wide clock, not adjusted for frequency scaling.  */
        CLOCK_MONOTONIC_RAW = 4;
        /* Identifier for system-wide realtime clock, updated only on ticks.  */
        CLOCK_REALTIME_COARSE = 5;
        /* Monotonic system-wide clock, updated only on ticks.  */
        CLOCK_MONOTONIC_COARSE = 6;
        /* Monotonic system-wide clock that includes time spent in suspension.  */
        CLOCK_BOOTTIME = 7;
        /* Like CLOCK_REALTIME but also wakes suspended system.  */
        CLOCK_REALTIME_ALARM = 8;
        /* Like CLOCK_BOOTTIME but also wakes suspended system.  */
        CLOCK_BOOTTIME_ALARM = 9;
        /* Like CLOCK_REALTIME but in International Atomic Time.  */
        CLOCK_TAI = 11;
        /* Flag to indicate time is absolute.  */
        TIMER_ABSTIME = 1;
    }
#endif

/************************************************************************
    mount.h
************************************************************************/

define {
    BLOCK_SIZE = 1024;
    BLOCK_SIZE_BITS = 10;
}

/* These are the fs-independent mount-flags: up to 16 flags are
   supported  */
enum {
    MS_RDONLY = 1,              /* Mount read-only.  */
    MS_NOSUID = 2,              /* Ignore suid and sgid bits.  */
    MS_NODEV = 4,               /* Disallow access to device special files.  */
    MS_NOEXEC = 8,              /* Disallow program execution.  */
    MS_SYNCHRONOUS = 16,        /* Writes are synced at once.  */
    MS_REMOUNT = 32,            /* Alter flags of a mounted FS.  */
    MS_MANDLOCK = 64,           /* Allow mandatory locks on an FS.  */
    MS_DIRSYNC = 128,           /* Directory modifications are synchronous.  */
    MS_NOATIME = 1024,          /* Do not update access times.  */
    MS_NODIRATIME = 2048,       /* Do not update directory access times.  */
    MS_BIND = 4096,             /* Bind directory at different place.  */
    MS_MOVE = 8192,
    MS_REC = 16384,
    MS_SILENT = 32768,
    MS_POSIXACL = 1 << 16,      /* VFS does not apply the umask.  */
    MS_UNBINDABLE = 1 << 17,    /* Change to unbindable.  */
    MS_PRIVATE = 1 << 18,       /* Change to private.  */
    MS_SLAVE = 1 << 19,         /* Change to slave.  */
    MS_SHARED = 1 << 20,        /* Change to shared.  */
    MS_RELATIME = 1 << 21,      /* Update atime relative to mtime/ctime.  */
    MS_KERNMOUNT = 1 << 22,     /* This is a kern_mount call.  */
    MS_I_VERSION =  1 << 23,    /* Update inode I_version field.  */
    MS_STRICTATIME = 1 << 24,   /* Always perform atime updates.  */
    MS_LAZYTIME = 1 << 25,      /* Update the on-disk [acm]times lazily.  */
    MS_ACTIVE = 1 << 30,
    MS_NOUSER = 1 << 31
}

/* Flags that can be altered by MS_REMOUNT  */
define {
    MS_RMT_MASK = (MS_RDONLY|MS_SYNCHRONOUS|MS_MANDLOCK|MS_I_VERSION|MS_LAZYTIME);
}

/* Magic mount flag number. Has to be or-ed to the flag values.  */
define {
    MS_MGC_VAL = 0xc0ed0000;    /* Magic flag number to indicate "new" flags */
    MS_MGC_MSK = 0xffff0000;    /* Magic flag number mask */
}

/* Possible value for FLAGS parameter of `umount2'.  */
enum {
    MNT_FORCE = 1,          /* Force unmounting.  */
    MNT_DETACH = 2,         /* Just detach from the tree.  */
    MNT_EXPIRE = 4,         /* Mark for expiry.  */
    UMOUNT_NOFOLLOW = 8     /* Don't follow symlink on umount.  */
}

/************************************************************************
    utime.h
************************************************************************/

/* Structure describing file times.  */
struct struct_utimbuf {
    actime __time_t;        /* Access time.  */
    modtime __time_t;       /* Modification time.  */
}

/************************************************************************
    asm-generic/sockios.h
************************************************************************/

/* Socket-level I/O control calls. */
define {
    FIOSETOWN = 0x8901;
    SIOCSPGRP = 0x8902;
    FIOGETOWN = 0x8903;
    SIOCGPGRP = 0x8904;
    SIOCATMARK = 0x8905;
    SIOCGSTAMP = 0x8906;        /* Get stamp (timeval) */
    SIOCGSTAMPNS = 0x8907;      /* Get stamp (timespec) */
}

/************************************************************************
    asm-generic/socket.h
************************************************************************/

/* For setsockopt(2) */
define {
    SOL_SOCKET = 1;
    SO_DEBUG = 1;
    SO_REUSEADDR = 2;
    SO_TYPE = 3;
    SO_ERROR = 4;
    SO_DONTROUTE = 5;
    SO_BROADCAST = 6;
    SO_SNDBUF = 7;
    SO_RCVBUF = 8;
    SO_SNDBUFFORCE = 32;
    SO_RCVBUFFORCE = 33;
    SO_KEEPALIVE = 9;
    SO_OOBINLINE = 10;
    SO_NO_CHECK = 11;
    SO_PRIORITY = 12;
    SO_LINGER = 13;
    SO_BSDCOMPAT = 14;
    SO_REUSEPORT = 15;
    #if !objectid(SO_PASSCRED); /* powerpc only differs in these */
        SO_PASSCRED = 16;
        SO_PEERCRED = 17;
        SO_RCVLOWAT = 18;
        SO_SNDLOWAT = 19;
        SO_RCVTIMEO = 20;
        SO_SNDTIMEO = 21;
    #endif
    /* Security levels - as per NRL IPv6 - don't actually do anything */
    SO_SECURITY_AUTHENTICATION = 22;
    SO_SECURITY_ENCRYPTION_TRANSPORT = 23;
    SO_SECURITY_ENCRYPTION_NETWORK = 24;
    SO_BINDTODEVICE = 25;
    /* Socket filtering */
    SO_ATTACH_FILTER = 26;
    SO_DETACH_FILTER = 27;
    SO_GET_FILTER = SO_ATTACH_FILTER;
    SO_PEERNAME = 28;
    SO_TIMESTAMP = 29;
    SCM_TIMESTAMP = SO_TIMESTAMP;
    SO_ACCEPTCONN = 30;
    SO_PEERSEC = 31;
    SO_PASSSEC = 34;
    SO_TIMESTAMPNS = 35;
    SCM_TIMESTAMPNS = SO_TIMESTAMPNS;
    SO_MARK = 36;
    SO_TIMESTAMPING = 37;
    SCM_TIMESTAMPING = SO_TIMESTAMPING;
    SO_PROTOCOL = 38;
    SO_DOMAIN = 39;
    SO_RXQ_OVFL = 40;
    SO_WIFI_STATUS = 41;
    SCM_WIFI_STATUS = SO_WIFI_STATUS;
    SO_PEEK_OFF = 42;
    /* Instruct lower device to use last 4-bytes of skb data as FCS */
    SO_NOFCS = 43;
    SO_LOCK_FILTER = 44;
    SO_SELECT_ERR_QUEUE = 45;
    SO_BUSY_POLL = 46;
    SO_MAX_PACING_RATE = 47;
    SO_BPF_EXTENSIONS = 48;
    SO_INCOMING_CPU = 49;
    SO_ATTACH_BPF = 50;
    SO_DETACH_BPF = SO_DETACH_FILTER;
    SO_ATTACH_REUSEPORT_CBPF = 51;
    SO_ATTACH_REUSEPORT_EBPF = 52;
    SO_CNX_ADVICE = 53;
    SCM_TIMESTAMPING_OPT_STATS = 54;
}

/************************************************************************
    bits/socket_type.h
************************************************************************/

/* Types of sockets.  */
enum {
    SOCK_STREAM = 1,            /* Sequenced, reliable, connection-based byte streams.  */
    SOCK_DGRAM = 2,             /* Connectionless, unreliable datagrams
                                    of fixed maximum length.  */
    SOCK_RAW = 3,               /* Raw protocol interface.  */
    SOCK_RDM = 4,               /* Reliably-delivered messages.  */
    SOCK_SEQPACKET = 5,         /* Sequenced, reliable, connection-based,
                                    datagrams of fixed maximum length.  */
    SOCK_DCCP = 6,              /* Datagram Congestion Control Protocol.  */
    SOCK_PACKET = 10,           /* Linux specific way of getting packets
                                    at the dev level.  For writing rarp and
                                    other similar things on the user level. */
    /* Flags to be ORed into the type parameter of socket and socketpair and
        used for the flags parameter of paccept.  */
    SOCK_CLOEXEC = 02000000,    /* Atomically set close-on-exec flag for the
                                    new descriptor(s).  */
    SOCK_NONBLOCK = 00004000    /* Atomically mark descriptor(s) as
                                    non-blocking.  */
}

/************************************************************************
    bits/sockaddr.h
************************************************************************/

typedef sa_family_t unsigned short;

define {
    __SOCKADDR_COMMON_SIZE = sizeof(unsigned short);
}

/* Size of struct sockaddr_storage.  */
define {
    _SS_SIZE = 128;
}

/************************************************************************
    bits/socket.h
************************************************************************/

typedef socklen_t __socklen_t;

/* Protocol families.  */
define {
    PF_UNSPEC = 0;          /* Unspecified.  */
    PF_LOCAL = 1;           /* Local to host (pipes and file-domain).  */
    PF_UNIX = PF_LOCAL;     /* POSIX name for PF_LOCAL.  */
    PF_FILE = PF_LOCAL;     /* Another non-standard name for PF_LOCAL.  */
    PF_INET = 2;            /* IP protocol family.  */
    PF_AX25 = 3;            /* Amateur Radio AX.25.  */
    PF_IPX = 4;             /* Novell Internet Protocol.  */
    PF_APPLETALK = 5;       /* Appletalk DDP.  */
    PF_NETROM = 6;          /* Amateur radio NetROM.  */
    PF_BRIDGE = 7;          /* Multiprotocol bridge.  */
    PF_ATMPVC = 8;          /* ATM PVCs.  */
    PF_X25 = 9;             /* Reserved for X.25 project.  */
    PF_INET6 = 10;          /* IP version 6.  */
    PF_ROSE = 11;           /* Amateur Radio X.25 PLP.  */
    PF_DECnet = 12;         /* Reserved for DECnet project.  */
    PF_NETBEUI = 13;        /* Reserved for 802.2LLC project.  */
    PF_SECURITY = 14;       /* Security callback pseudo AF.  */
    PF_KEY = 15;            /* PF_KEY key management API.  */
    PF_NETLINK = 16;
    PF_ROUTE = PF_NETLINK;  /* Alias to emulate 4.4BSD.  */
    PF_PACKET = 17;         /* Packet family.  */
    PF_ASH = 18;            /* Ash.  */
    PF_ECONET = 19;         /* Acorn Econet.  */
    PF_ATMSVC = 20;         /* ATM SVCs.  */
    PF_RDS = 21;            /* RDS sockets.  */
    PF_SNA = 22;            /* Linux SNA Project */
    PF_IRDA = 23;           /* IRDA sockets.  */
    PF_PPPOX = 24;          /* PPPoX sockets.  */
    PF_WANPIPE = 25;        /* Wanpipe API sockets.  */
    PF_LLC = 26;            /* Linux LLC.  */
    PF_IB = 27;             /* Native InfiniBand address.  */
    PF_MPLS = 28;           /* MPLS.  */
    PF_CAN = 29;            /* Controller Area Network.  */
    PF_TIPC = 30;           /* TIPC sockets.  */
    PF_BLUETOOTH = 31;      /* Bluetooth sockets.  */
    PF_IUCV = 32;           /* IUCV sockets.  */
    PF_RXRPC = 33;          /* RxRPC sockets.  */
    PF_ISDN = 34;           /* mISDN sockets.  */
    PF_PHONET = 35;         /* Phonet sockets.  */
    PF_IEEE802154 = 36;     /* IEEE 802.15.4 sockets.  */
    PF_CAIF = 37;           /* CAIF sockets.  */
    PF_ALG = 38;            /* Algorithm sockets.  */
    PF_NFC = 39;            /* NFC sockets.  */
    PF_VSOCK = 40;          /* vSockets.  */
    PF_KCM = 41;            /* Kernel Connection Multiplexor.  */
    PF_QIPCRTR = 42;        /* Qualcomm IPC Router.  */
    PF_MAX = 43;            /* For now..  */
}

/* Address families.  */
define {
    AF_UNSPEC = PF_UNSPEC;
    AF_LOCAL = PF_LOCAL;
    AF_UNIX = PF_UNIX;
    AF_FILE = PF_FILE;
    AF_INET = PF_INET;
    AF_AX25 = PF_AX25;
    AF_IPX = PF_IPX;
    AF_APPLETALK = PF_APPLETALK;
    AF_NETROM = PF_NETROM;
    AF_BRIDGE = PF_BRIDGE;
    AF_ATMPVC = PF_ATMPVC;
    AF_X25 = PF_X25;
    AF_INET6 = PF_INET6;
    AF_ROSE = PF_ROSE;
    AF_DECnet = PF_DECnet;
    AF_NETBEUI = PF_NETBEUI;
    AF_SECURITY = PF_SECURITY;
    AF_KEY = PF_KEY;
    AF_NETLINK = PF_NETLINK;
    AF_ROUTE = PF_ROUTE;
    AF_PACKET = PF_PACKET;
    AF_ASH = PF_ASH;
    AF_ECONET = PF_ECONET;
    AF_ATMSVC = PF_ATMSVC;
    AF_RDS = PF_RDS;
    AF_SNA = PF_SNA;
    AF_IRDA = PF_IRDA;
    AF_PPPOX = PF_PPPOX;
    AF_WANPIPE = PF_WANPIPE;
    AF_LLC = PF_LLC;
    AF_IB = PF_IB;
    AF_MPLS = PF_MPLS;
    AF_CAN = PF_CAN;
    AF_TIPC = PF_TIPC;
    AF_BLUETOOTH = PF_BLUETOOTH;
    AF_IUCV = PF_IUCV;
    AF_RXRPC = PF_RXRPC;
    AF_ISDN = PF_ISDN;
    AF_PHONET = PF_PHONET;
    AF_IEEE802154 = PF_IEEE802154;
    AF_CAIF = PF_CAIF;
    AF_ALG = PF_ALG;
    AF_NFC = PF_NFC;
    AF_VSOCK = PF_VSOCK;
    AF_KCM = PF_KCM;
    AF_QIPCRTR = PF_QIPCRTR;
    AF_MAX = PF_MAX;
}

/* Socket level values.  Others are defined in the appropriate headers.

   XXX These definitions also should go into the appropriate headers as
   far as they are available.  */
define {
    SOL_RAW = 255;
    SOL_DECNET = 261;
    SOL_X25 = 262;
    SOL_PACKET = 263;
    SOL_ATM = 264;    /* ATM layer (cell level).  */
    SOL_AAL = 265;    /* ATM Adaption Layer (packet level).  */
    SOL_IRDA = 266;
    SOL_NETBEUI = 267;
    SOL_LLC = 268;
    SOL_DCCP = 269;
    SOL_NETLINK = 270;
    SOL_TIPC = 271;
    SOL_RXRPC = 272;
    SOL_PPPOL2TP = 273;
    SOL_BLUETOOTH = 274;
    SOL_PNPIPE = 275;
    SOL_RDS = 276;
    SOL_IUCV = 277;
    SOL_CAIF = 278;
    SOL_ALG = 279;
    SOL_NFC = 280;
    SOL_KCM = 281;
}

/* Maximum queue length specifiable by listen.  */
define {
    SOMAXCONN = 128;
}

/* Structure describing a generic socket address.  */
struct struct_sockaddr {
    sa_family sa_family_t;  /* Common data: address family and length.  */
    sa_data(14) char;       /* Address data.  */
}

/* Structure large enough to hold any socket address (with the historical
   exception of AF_UNIX).  */
define {
    __ss_aligntype = unsigned long;
    _SS_PADSIZE = _SS_SIZE - __SOCKADDR_COMMON_SIZE - sizeof(__ss_aligntype);
}

struct struct_sockaddr_storage {
    ss_family sa_family_t;          /* Address family, etc.  */
    __ss_padding(_SS_PADSIZE) char;
    __ss_align __ss_aligntype;      /* Force desired alignment.  */
}

/* Bits in the FLAGS argument to `send', `recv', et al.  */
enum {
    MSG_OOB = 0x01,                 /* Process out-of-band data.  */
    MSG_PEEK = 0x02,                /* Peek at incoming messages.  */
    MSG_DONTROUTE = 0x04,           /* Don't use local routing.  */
#if objectid(__USE_GNU);
    /* DECnet uses a different name.  */
    MSG_TRYHARD = MSG_DONTROUTE,
#endif
    MSG_CTRUNC = 0x08,              /* Control data lost before delivery.  */
    MSG_PROXY = 0x10,               /* Supply or ask second address.  */
    MSG_TRUNC = 0x20,
    MSG_DONTWAIT = 0x40,            /* Nonblocking IO.  */
    MSG_EOR = 0x80,                 /* End of record.  */
    MSG_WAITALL = 0x100,            /* Wait for a full request.  */
    MSG_FIN = 0x200,
    MSG_SYN = 0x400,
    MSG_CONFIRM = 0x800,            /* Confirm path validity.  */
    MSG_RST = 0x1000,
    MSG_ERRQUEUE = 0x2000,          /* Fetch message from error queue.  */
    MSG_NOSIGNAL = 0x4000,          /* Do not generate SIGPIPE.  */
    MSG_MORE = 0x8000,              /* Sender will send more.  */
    MSG_WAITFORONE = 0x10000,       /* Wait for at least one packet to return.*/
    MSG_BATCH = 0x40000,            /* sendmmsg: more messages coming.  */
    MSG_FASTOPEN = 0x20000000,      /* Send data in TCP SYN.  */
    MSG_CMSG_CLOEXEC = 0x40000000   /* Set close_on_exit for file
                                        descriptor received through
                                        SCM_RIGHTS.  */
}

/* Structure used to manipulate the SO_LINGER option.  */
struct struct_linger {
    l_onoff int;        /* Nonzero to linger on close.  */
    l_linger int;       /* Time to linger.  */
}

/************************************************************************
    sys/socket.h
************************************************************************/

/* The following constants should be used for the second parameter of
   `shutdown'.  */
enum {
    SHUT_RD = 0,    /* No more receptions.  */
    SHUT_WR,        /* No more transmissions.  */
    SHUT_RDWR       /* No more receptions or transmissions.  */
}

/************************************************************************
    netinet/in.h
************************************************************************/

/* Internet address.  */
typedef in_addr_t uint32;

struct struct_in_addr {
    s_addr in_addr_t;
}

/* Standard well-defined IP protocols.  */
enum {
    IPPROTO_IP = 0,         /* Dummy protocol for TCP.  */
    IPPROTO_ICMP = 1,       /* Internet Control Message Protocol.  */
    IPPROTO_IGMP = 2,       /* Internet Group Management Protocol. */
    IPPROTO_IPIP = 4,       /* IPIP tunnels (older KA9Q tunnels use 94).  */
    IPPROTO_TCP = 6,        /* Transmission Control Protocol.  */
    IPPROTO_EGP = 8,        /* Exterior Gateway Protocol.  */
    IPPROTO_PUP = 12,       /* PUP protocol.  */
    IPPROTO_UDP = 17,       /* User Datagram Protocol.  */
    IPPROTO_IDP = 22,       /* XNS IDP protocol.  */
    IPPROTO_TP = 29,        /* SO Transport Protocol Class 4.  */
    IPPROTO_DCCP = 33,      /* Datagram Congestion Control Protocol.  */
    IPPROTO_IPV6 = 41,      /* IPv6 header.  */
    IPPROTO_RSVP = 46,      /* Reservation Protocol.  */
    IPPROTO_GRE = 47,       /* General Routing Encapsulation.  */
    IPPROTO_ESP = 50,       /* encapsulating security payload.  */
    IPPROTO_AH = 51,        /* authentication header.  */
    IPPROTO_MTP = 92,       /* Multicast Transport Protocol.  */
    IPPROTO_BEETPH = 94,    /* IP option pseudo header for BEET.  */
    IPPROTO_ENCAP = 98,     /* Encapsulation Header.  */
    IPPROTO_PIM = 103,      /* Protocol Independent Multicast.  */
    IPPROTO_COMP = 108,     /* Compression Header Protocol.  */
    IPPROTO_SCTP = 132,     /* Stream Control Transmission Protocol.  */
    IPPROTO_UDPLITE = 136,  /* UDP-Lite protocol.  */
    IPPROTO_MPLS = 137,     /* MPLS in IP.  */
    IPPROTO_RAW = 255,      /* Raw IP packets.  */
    IPPROTO_MAX
}

/* If __USE_KERNEL_IPV6_DEFS is 1 then the user has included the kernel
    network headers first and we should use those ABI-identical definitions
    instead of our own, otherwise 0.  */
#if !objectid(__USE_KERNEL_IPV6_DEFS);
    enum {
        IPPROTO_HOPOPTS = 0,   /* IPv6 Hop-by-Hop options.  */
        IPPROTO_ROUTING = 43,  /* IPv6 routing header.  */
        IPPROTO_FRAGMENT = 44, /* IPv6 fragmentation header.  */
        IPPROTO_ICMPV6 = 58,   /* ICMPv6.  */
        IPPROTO_NONE = 59,     /* IPv6 no next header.  */
        IPPROTO_DSTOPTS = 60,  /* IPv6 destination options.  */
        IPPROTO_MH = 135       /* IPv6 mobility header.  */
    }
#endif

/* Type to represent a port.  */
typedef in_port_t uint16;

/* Standard well-known ports.  */
enum {
    IPPORT_ECHO = 7,            /* Echo service.  */
    IPPORT_DISCARD = 9,         /* Discard transmissions service.  */
    IPPORT_SYSTAT = 11,         /* System status service.  */
    IPPORT_DAYTIME = 13,        /* Time of day service.  */
    IPPORT_NETSTAT = 15,        /* Network status service.  */
    IPPORT_FTP = 21,            /* File Transfer Protocol.  */
    IPPORT_TELNET = 23,         /* Telnet protocol.  */
    IPPORT_SMTP = 25,           /* Simple Mail Transfer Protocol.  */
    IPPORT_TIMESERVER = 37,     /* Timeserver service.  */
    IPPORT_NAMESERVER = 42,     /* Domain Name Service.  */
    IPPORT_WHOIS = 43,          /* Internet Whois service.  */
    IPPORT_MTP = 57,
    IPPORT_TFTP = 69,           /* Trivial File Transfer Protocol.  */
    IPPORT_RJE = 77,
    IPPORT_FINGER = 79,         /* Finger service.  */
    IPPORT_TTYLINK = 87,
    IPPORT_SUPDUP = 95,         /* SUPDUP protocol.  */
    IPPORT_EXECSERVER = 512,    /* execd service.  */
    IPPORT_LOGINSERVER = 513,   /* rlogind service.  */
    IPPORT_CMDSERVER = 514,
    IPPORT_EFSSERVER = 520,
    /* UDP ports.  */
    IPPORT_BIFFUDP = 512,
    IPPORT_WHOSERVER = 513,
    IPPORT_ROUTESERVER = 520,
    /* Ports less than this value are reserved for privileged processes.  */
    IPPORT_RESERVED = 1024,
    /* Ports greater this value are reserved for (non-privileged) servers.  */
    IPPORT_USERRESERVED = 5000
}

define {
    /* Address to accept any incoming messages.  */
    INADDR_ANY = in_addr_t(0x00000000);
    /* Address to send to all hosts.  */
    INADDR_BROADCAST = in_addr_t(0xffffffff);
    /* Address indicating an error return.  */
    INADDR_NONE = in_addr_t(0xffffffff);
    /* Network number for local host loopback.  */
    IN_LOOPBACKNET = 127;
    /* Address to loopback in software to local host.  */
    INADDR_LOOPBACK = in_addr_t(0x7f000001); /* Inet 127.0.0.1.  */
}

#if !objectid(__USE_KERNEL_IPV6_DEFS);
    /* IPv6 address */
    struct struct_in6_addr {
        union __in6_u {
            __u6_addr8(16) uint8;
            __u6_addr16(8) uint16;
            __u6_addr32(4) uint32;
        }
        // #define s6_addr __in6_u.__u6_addr8
        #if objectid(__USE_MISC);
            // #define s6_addr16 __in6_u.__u6_addr16
            // #define s6_addr32 __in6_u.__u6_addr32
        #endif
    }
#endif

define {
    INET_ADDRSTRLEN = 16;
    INET6_ADDRSTRLEN = 46;
}

/* Structure describing an Internet socket address.  */
struct struct_sockaddr_in {
    sin_family sa_family_t;
    sin_port in_port_t;         /* Port number.  */
    sin_addr struct_in_addr;    /* Internet address.  */
    /* Pad to size of `struct sockaddr'.  */
    sin_zero(sizeof(struct_sockaddr) -
               __SOCKADDR_COMMON_SIZE -
               sizeof(in_port_t) -
               sizeof(struct_in_addr)) unsigned char;
}

#if !objectid(__USE_KERNEL_IPV6_DEFS);
    /* Ditto, for IPv6.  */
    struct struct_sockaddr_in6 {
        sin6_family sa_family_t;
        sin6_port in_port_t;        /* Transport layer port # */
        sin6_flowinfo uint32;     /* IPv6 flow information */
        sin6_addr struct_in6_addr;  /* IPv6 address */
        sin6_scope_id uint32;     /* IPv6 scope-id */
    }
#endif

/************************************************************************
    bits/in.h
************************************************************************/

/* Options for use with `getsockopt' and `setsockopt' at the IP level.
   The first word in the comment at the right is the data type used;
   "bool" means a boolean value stored in an `int'.  */
define {
    IP_OPTIONS = 4;                 /* ip_opts; IP per-packet options.  */
    IP_HDRINCL = 3;                 /* int; Header is included with data.  */
    IP_TOS = 1;                     /* int; IP type of service and precedence.  */
    IP_TTL = 2;                     /* int; IP time to live.  */
    IP_RECVOPTS = 6;                /* bool; Receive all IP options w/datagram.  */
    /* For BSD compatibility.  */
    IP_RECVRETOPTS = IP_RETOPTS;    /* bool; Receive IP options for response.  */
    IP_RETOPTS = 7;                 /* ip_opts; Set/get IP per-packet options.  */
    IP_MULTICAST_IF = 32;           /* in_addr; set/get IP multicast i/f */
    IP_MULTICAST_TTL = 33;          /* unsigned char; set/get IP multicast ttl */
    IP_MULTICAST_LOOP = 34;         /* bool; set/get IP multicast loopback */
    IP_ADD_MEMBERSHIP = 35;         /* ip_mreq; add an IP group membership */
    IP_DROP_MEMBERSHIP = 36;        /* ip_mreq; drop an IP group membership */
    IP_UNBLOCK_SOURCE = 37;         /* ip_mreq_source: unblock data from source */
    IP_BLOCK_SOURCE = 38;           /* ip_mreq_source: block data from source */
    IP_ADD_SOURCE_MEMBERSHIP = 39;  /* ip_mreq_source: join source group */
    IP_DROP_SOURCE_MEMBERSHIP = 40; /* ip_mreq_source: leave source group */
    IP_MSFILTER = 41;
#if objectid(__USE_MISC);
    MCAST_JOIN_GROUP = 42;          /* group_req: join any-source group */
    MCAST_BLOCK_SOURCE = 43;        /* group_source_req: block from given group */
    MCAST_UNBLOCK_SOURCE = 44;      /* group_source_req: unblock from given group*/
    MCAST_LEAVE_GROUP = 45;         /* group_req: leave any-source group */
    MCAST_JOIN_SOURCE_GROUP = 46;   /* group_source_req: join source-spec gr */
    MCAST_LEAVE_SOURCE_GROUP = 47;  /* group_source_req: leave source-spec gr*/
    MCAST_MSFILTER = 48;
    MCAST_EXCLUDE = 0;
    MCAST_INCLUDE = 1;
#endif
    IP_ROUTER_ALERT = 5;            /* bool */
    IP_PKTINFO = 8;                 /* bool */
    IP_PKTOPTIONS = 9;
    IP_PMTUDISC = 10;               /* obsolete name? */
    IP_MTU_DISCOVER = 10;           /* int; see below */
    IP_RECVERR = 11;                /* bool */
    IP_RECVTTL = 12;                /* bool */
    IP_RECVTOS = 13;                /* bool */
    IP_MTU = 14;                    /* int */
    IP_FREEBIND = 15;
    IP_IPSEC_POLICY = 16;
    IP_XFRM_POLICY = 17;
    IP_PASSSEC = 18;
    IP_TRANSPARENT = 19;
    IP_MULTICAST_ALL = 49;          /* bool */
    /* TProxy original addresses */
    IP_ORIGDSTADDR = 20;
    IP_RECVORIGDSTADDR = IP_ORIGDSTADDR;
    IP_MINTTL = 21;
    IP_NODEFRAG = 22;
    IP_CHECKSUM = 23;
    IP_BIND_ADDRESS_NO_PORT = 24;
    /* IP_MTU_DISCOVER arguments.  */
    IP_PMTUDISC_DONT = 0;           /* Never send DF frames.  */
    IP_PMTUDISC_WANT = 1;           /* Use per route hints.  */
    IP_PMTUDISC_DO = 2;             /* Always DF.  */
    IP_PMTUDISC_PROBE = 3;          /* Ignore dst pmtu.  */
    /* Always use interface mtu (ignores dst pmtu) but don't set DF flag.
        Also incoming ICMP frag_needed notifications will be ignored on
        this socket to prevent accepting spoofed ones.  */
    IP_PMTUDISC_INTERFACE = 4;
    /* Like IP_PMTUDISC_INTERFACE but allow packets to be fragmented.  */
    IP_PMTUDISC_OMIT = 5;
    IP_UNICAST_IF = 50;
}

/* To select the IP level.  */
define {
    SOL_IP = 0;
}

define {
    IP_DEFAULT_MULTICAST_TTL = 1;
    IP_DEFAULT_MULTICAST_LOOP = 1;
    IP_MAX_MEMBERSHIPS = 20;
}

#if objectid(__USE_MISC);
        /* Structure used to describe IP options for IP_OPTIONS and IP_RETOPTS.
        The `ip_dst' field is used for the first-hop gateway when using a
        source route (this gets put into the header proper).  */
    struct struct_ip_opts {
        ip_dst struct_in_addr;  /* First hop; zero without source route.  */
        ip_opts(40) char;       /* Actually variable in size.  */
    }

    /* Like `struct ip_mreq' but including interface specification by index.  */
    struct struct_ip_mreqn {
        imr_multiaddr struct_in_addr;   /* IP multicast address of group */
        imr_address struct_in_addr;     /* local IP address of interface */
        imr_ifindex int;                /* Interface index */
    }

    /* Structure used for IP_PKTINFO.  */
    struct struct_in_pktinfo {
        ipi_ifindex int;                /* Interface index  */
        ipi_spec_dst struct_in_addr;    /* Routing destination address  */
        ipi_addr struct_in_addr;        /* Header destination address  */
    }
#endif

/* Options for use with `getsockopt' and `setsockopt' at the IPv6 level.
   The first word in the comment at the right is the data type used;
   "bool" means a boolean value stored in an `int'.  */
define {
    IPV6_ADDRFORM = 1;
    IPV6_2292PKTINFO = 2;
    IPV6_2292HOPOPTS = 3;
    IPV6_2292DSTOPTS = 4;
    IPV6_2292RTHDR = 5;
    IPV6_2292PKTOPTIONS = 6;
    IPV6_CHECKSUM = 7;
    IPV6_2292HOPLIMIT = 8;
    SCM_SRCRT = IPV6_RXSRCRT;
    IPV6_NEXTHOP = 9;
    IPV6_AUTHHDR = 10;
    IPV6_UNICAST_HOPS = 16;
    IPV6_MULTICAST_IF = 17;
    IPV6_MULTICAST_HOPS = 18;
    IPV6_MULTICAST_LOOP = 19;
    IPV6_JOIN_GROUP = 20;
    IPV6_LEAVE_GROUP = 21;
    IPV6_ROUTER_ALERT = 22;
    IPV6_MTU_DISCOVER = 23;
    IPV6_MTU = 24;
    IPV6_RECVERR = 25;
    IPV6_V6ONLY = 26;
    IPV6_JOIN_ANYCAST = 27;
    IPV6_LEAVE_ANYCAST = 28;
    IPV6_IPSEC_POLICY = 34;
    IPV6_XFRM_POLICY = 35;
    IPV6_HDRINCL = 36;
    /* Advanced API (RFC3542) (1).  */
    IPV6_RECVPKTINFO = 49;
    IPV6_PKTINFO = 50;
    IPV6_RECVHOPLIMIT = 51;
    IPV6_HOPLIMIT = 52;
    IPV6_RECVHOPOPTS = 53;
    IPV6_HOPOPTS = 54;
    IPV6_RTHDRDSTOPTS = 55;
    IPV6_RECVRTHDR = 56;
    IPV6_RTHDR = 57;
    IPV6_RECVDSTOPTS = 58;
    IPV6_DSTOPTS = 59;
    IPV6_RECVPATHMTU = 60;
    IPV6_PATHMTU = 61;
    IPV6_DONTFRAG = 62;
    /* Advanced API (RFC3542) (2).  */
    IPV6_RECVTCLASS = 66;
    IPV6_TCLASS = 67;
    /* Obsolete synonyms for the above.  */
    #if !objectid(__USE_KERNEL_IPV6_DEFS);
        IPV6_ADD_MEMBERSHIP = IPV6_JOIN_GROUP;
        IPV6_DROP_MEMBERSHIP = IPV6_LEAVE_GROUP;
    #endif
    IPV6_RXHOPOPTS = IPV6_HOPOPTS;
    IPV6_RXDSTOPTS = IPV6_DSTOPTS;
    /* IPV6_MTU_DISCOVER values.  */
    IPV6_PMTUDISC_DONT = 0;    /* Never send DF frames.  */
    IPV6_PMTUDISC_WANT = 1;    /* Use per route hints.  */
    IPV6_PMTUDISC_DO = 2;    /* Always DF.  */
    IPV6_PMTUDISC_PROBE = 3;    /* Ignore dst pmtu.  */
    IPV6_PMTUDISC_INTERFACE = 4;    /* See IP_PMTUDISC_INTERFACE.  */
    IPV6_PMTUDISC_OMIT = 5;    /* See IP_PMTUDISC_OMIT.  */
    /* Socket level values for IPv6.  */
    SOL_IPV6 = 41;
    SOL_ICMPV6 = 58;
    /* Routing header options for IPv6.  */
    IPV6_RTHDR_LOOSE = 0;    /* Hop doesn't need to be neighbour. */
    IPV6_RTHDR_STRICT = 1;    /* Hop must be a neighbour.  */
    IPV6_RTHDR_TYPE_0 = 0;    /* IPv6 Routing header type 0.  */
}

/************************************************************************
    bits/netdb.h
************************************************************************/

/* Description of data base entry for a single network.  NOTE: here a
   poor assumption is made.  The network number is expected to fit
   into an unsigned long int variable.  */
struct struct_netent {
    n_name. char;       /* Official name of network.  */
    n_aliases++ char;   /* Alias list.  */
    n_addrtype int;     /* Net address type.  */
    n_net uint32;     /* Network number.  */
}

/************************************************************************
    netdb.h
************************************************************************/

/* Description of data base entry for a single host.  */
struct struct_hostent {
    h_name. char;           /* Official name of host.  */
    h_aliases++ char;       /* Alias list.  */
    h_addrtype int;         /* Host address type.  */
    h_length int;           /* Length of address.  */
    h_addr_list++ char;     /* List of addresses from name server.  */
    #if objectid(__USE_MISC);
        // #define h_addr h_addr_list[0] /* Address, for backward compatibility.*/
    #endif
}

/* Description of data base entry for a single service.  */
struct struct_servent {
    s_name. char;       /* Official service name.  */
    s_aliases++ char;   /* Alias list.  */
    s_port int;         /* Port number.  */
    s_proto. char;      /* Protocol to use.  */
}

/************************************************************************
    bits/locale.h
************************************************************************/

define {
    __LC_CTYPE = 0;
    __LC_NUMERIC = 1;
    __LC_TIME = 2;
    __LC_COLLATE = 3;
    __LC_MONETARY = 4;
    __LC_MESSAGES = 5;
    __LC_ALL = 6;
    __LC_PAPER = 7;
    __LC_NAME = 8;
    __LC_ADDRESS = 9;
    __LC_TELEPHONE = 10;
    __LC_MEASUREMENT = 11;
    __LC_IDENTIFICATION = 12;
}

/************************************************************************
    locale.h
************************************************************************/

/* These are the possibilities for the first argument to setlocale.
   The code assumes that the lowest LC_* symbol has the value zero.  */
define {
    LC_CTYPE = __LC_CTYPE;
    LC_NUMERIC = __LC_NUMERIC;
    LC_TIME = __LC_TIME;
    LC_COLLATE = __LC_COLLATE;
    LC_MONETARY = __LC_MONETARY;
    LC_MESSAGES = __LC_MESSAGES;
    LC_ALL = __LC_ALL;
    LC_PAPER = __LC_PAPER;
    LC_NAME = __LC_NAME;
    LC_ADDRESS = __LC_ADDRESS;
    LC_TELEPHONE = __LC_TELEPHONE;
    LC_MEASUREMENT = __LC_MEASUREMENT;
    LC_IDENTIFICATION = __LC_IDENTIFICATION;
}

/* Structure giving information about numeric and monetary notation.  */
struct struct_lconv {
    /* Numeric (non-monetary) information.  */
    decimal_point. char;        /* Decimal point character.  */
    thousands_sep. char;        /* Thousands separator.  */
    /* Each element is the number of digits in each group;
        elements with higher indices are farther left.
        An element with value CHAR_MAX means that no further grouping is done.
        An element with value 0 means that the previous element is used
        for all groups farther left.  */
    grouping. char;
    /* Monetary information.  */
    /* First three chars are a currency symbol from ISO 4217.
        Fourth char is the separator.  Fifth char is '\0'.  */
    int_curr_symbol. char;
    currency_symbol. char;      /* Local currency symbol.  */
    mon_decimal_point. char;    /* Decimal point character.  */
    mon_thousands_sep. char;    /* Thousands separator.  */
    mon_grouping. char;         /* Like `grouping' element (above).  */
    positive_sign. char;        /* Sign for positive values.  */
    negative_sign. char;        /* Sign for negative values.  */
    int_frac_digits char;       /* Int'l fractional digits.  */
    frac_digits char;           /* Local fractional digits.  */
    /* 1 if currency_symbol precedes a positive value, 0 if succeeds.  */
    p_cs_precedes char;
    /* 1 iff a space separates currency_symbol from a positive value.  */
    p_sep_by_space char;
    /* 1 if currency_symbol precedes a negative value, 0 if succeeds.  */
    n_cs_precedes char;
    /* 1 iff a space separates currency_symbol from a negative value.  */
    n_sep_by_space char;
    /* Positive and negative sign positions:
        0 Parentheses surround the quantity and currency_symbol.
        1 The sign string precedes the quantity and currency_symbol.
        2 The sign string follows the quantity and currency_symbol.
        3 The sign string immediately precedes the currency_symbol.
        4 The sign string immediately follows the currency_symbol.  */
    p_sign_posn char;
    n_sign_posn char;
#if objectid(__USE_ISOC99);
    /* 1 if int_curr_symbol precedes a positive value, 0 if succeeds.  */
    int_p_cs_precedes char;
    /* 1 iff a space separates int_curr_symbol from a positive value.  */
    int_p_sep_by_space char;
    /* 1 if int_curr_symbol precedes a negative value, 0 if succeeds.  */
    int_n_cs_precedes char;
    /* 1 iff a space separates int_curr_symbol from a negative value.  */
    int_n_sep_by_space char;
    /* Positive and negative sign positions:
        0 Parentheses surround the quantity and int_curr_symbol.
        1 The sign string precedes the quantity and int_curr_symbol.
        2 The sign string follows the quantity and int_curr_symbol.
        3 The sign string immediately precedes the int_curr_symbol.
        4 The sign string immediately follows the int_curr_symbol.  */
    int_p_sign_posn char;
    int_n_sign_posn char;
#else
    __int_p_cs_precedes char;
    __int_p_sep_by_space char;
    __int_n_cs_precedes char;
    __int_n_sep_by_space char;
    __int_p_sign_posn char;
    __int_n_sign_posn char;
#endif
}

/************************************************************************
    bits/signum.h
************************************************************************/

/* Fake signal functions.  */
define {
    SIG_ERR = __sighandler_t(-1);   /* Error return.  */
    SIG_DFL = __sighandler_t(0);    /* Default action.  */
    SIG_IGN = __sighandler_t(1);    /* Ignore signal.  */
#if objectid(__USE_UNIX98);
    SIG_HOLD = __sighandler_t(2);   /* Add signal to hold mask.  */
#endif
}

/* Signals.  */
define {
    SIGHUP = 1;         /* Hangup (POSIX).  */
    SIGINT = 2;         /* Interrupt (ANSI).  */
    SIGQUIT = 3;        /* Quit (POSIX).  */
    SIGILL = 4;         /* Illegal instruction (ANSI).  */
    SIGTRAP = 5;        /* Trace trap (POSIX).  */
    SIGABRT = 6;        /* Abort (ANSI).  */
    SIGIOT = 6;         /* IOT trap (4.2 BSD).  */
    SIGBUS = 7;         /* BUS error (4.2 BSD).  */
    SIGFPE = 8;         /* Floating-point exception (ANSI).  */
    SIGKILL = 9;        /* Kill, unblockable (POSIX).  */
    SIGUSR1 = 10;       /* User-defined signal 1 (POSIX).  */
    SIGSEGV = 11;       /* Segmentation violation (ANSI).  */
    SIGUSR2 = 12;       /* User-defined signal 2 (POSIX).  */
    SIGPIPE = 13;       /* Broken pipe (POSIX).  */
    SIGALRM = 14;       /* Alarm clock (POSIX).  */
    SIGTERM = 15;       /* Termination (ANSI).  */
    SIGSTKFLT = 16;     /* Stack fault.  */
    SIGCLD = SIGCHLD;   /* Same as SIGCHLD (System V).  */
    SIGCHLD = 17;       /* Child status has changed (POSIX).  */
    SIGCONT = 18;       /* Continue (POSIX).  */
    SIGSTOP = 19;       /* Stop, unblockable (POSIX).  */
    SIGTSTP = 20;       /* Keyboard stop (POSIX).  */
    SIGTTIN = 21;       /* Background read from tty (POSIX).  */
    SIGTTOU = 22;       /* Background write to tty (POSIX).  */
    SIGURG = 23;        /* Urgent condition on socket (4.2 BSD).  */
    SIGXCPU = 24;       /* CPU limit exceeded (4.2 BSD).  */
    SIGXFSZ = 25;       /* File size limit exceeded (4.2 BSD).  */
    SIGVTALRM = 26;     /* Virtual alarm clock (4.2 BSD).  */
    SIGPROF = 27;       /* Profiling alarm clock (4.2 BSD).  */
    SIGWINCH = 28;      /* Window size change (4.3 BSD, Sun).  */
    SIGPOLL = SIGIO;    /* Pollable event occurred (System V).  */
    SIGIO = 29;         /* I/O now possible (4.2 BSD).  */
    SIGPWR = 30;        /* Power failure restart (System V).  */
    SIGSYS = 31;        /* Bad system call.  */
    SIGUNUSED = 31;
}

/************************************************************************
    signal.h
************************************************************************/

typedef __sighandler_t void;

/************************************************************************
    select.h
************************************************************************/

/* The fd_set member is required to be an array of longs.  */
typedef __fd_mask long;

/* It's easier to assume 8-bit bytes than to get CHAR_BIT.  */
define {
    __NFDBITS = 8 * int(sizeof(__fd_mask));
}

inline __FD_ELT(d int) int {
    return d / __NFDBITS;
}
inline __FD_MASK(d int) __fd_mask {
    return __fd_mask(unsigned long(1) << (d % __NFDBITS));
}

/* fd_set for select and pselect.  */
struct fd_set {
    /* XPG4.2 requires this member name.  Otherwise avoid the name
        from the global namespace.  */
#if objectid(__USE_XOPEN);
    fds_bits(__FD_SETSIZE / __NFDBITS) __fd_mask;
    // #define __FDS_BITS(set) ((set)->fds_bits)
#else
    __fds_bits(__FD_SETSIZE / __NFDBITS) __fd_mask;
    // #define __FDS_BITS(set) ((set)->__fds_bits)
#endif
}

/* Maximum number of file descriptors in `fd_set'.  */
define {
    FD_SETSIZE = __FD_SETSIZE;
}

#if objectid(__USE_MISC);
    /* Sometimes the fd_set member is assumed to have this type.  */
    typedef fd_mask __fd_mask;

    /* Number of bits per word of `fd_set' (some code assumes this is 32).  */
    define {
        NFDBITS = __NFDBITS;
    }
#endif

/************************************************************************
    sys/poll.h
************************************************************************/

/* Type used for the number of file descriptors.  */
typedef nfds_t unsigned long;

/* Data structure describing a polling request.  */
struct struct_pollfd {
    fd int;         /* File descriptor to poll.  */
    events short;   /* Types of events poller cares about.  */
    revents short;  /* Types of events that actually occurred.  */
}

/************************************************************************
    bits/mman-linux.h
************************************************************************/

/* Protections are chosen from these bits, OR'd together.  The
   implementation does not necessarily support PROT_EXEC or PROT_WRITE
   without PROT_READ.  The only guarantees are that no writing will be
   allowed without PROT_WRITE and no access will be allowed for PROT_NONE. */
define {
    PROT_READ = 0x1;                /* Page can be read.  */
    PROT_WRITE = 0x2;               /* Page can be written.  */
    PROT_EXEC = 0x4;                /* Page can be executed.  */
    PROT_NONE = 0x0;                /* Page can not be accessed.  */
    PROT_GROWSDOWN = 0x01000000;    /* Extend change to start of
                                        growsdown vma (mprotect only).  */
    PROT_GROWSUP = 0x02000000;      /* Extend change to start of
                                        growsup vma (mprotect only).  */
}

/* Sharing types (must choose one and only one of these).  */
define {
    MAP_SHARED = 0x01;              /* Share changes.  */
    MAP_PRIVATE = 0x02;             /* Changes are private.  */
    #if objectid(__USE_MISC);
        MAP_TYPE = 0x0f;            /* Mask for type of mapping.  */
    #endif
    /* Other flags.  */
    MAP_FIXED = 0x10;               /* Interpret addr exactly.  */
    #if objectid(__USE_MISC);
        MAP_FILE = 0;
        MAP_ANONYMOUS = 0x20;       /* Don't use a file.  */
        MAP_ANON = MAP_ANONYMOUS;
        /* When MAP_HUGETLB is set bits [26:31] encode the log2 of the huge page size.  */
        MAP_HUGE_SHIFT = 26;
        MAP_HUGE_MASK = 0x3f;
    #endif
}

/************************************************************************
    bits/mman.h
************************************************************************/

/* These are Linux-specific.  */
#if objectid(__USE_MISC);
    define {
        MAP_GROWSDOWN = 0x00100;    /* Stack-like segment.  */
        MAP_DENYWRITE = 0x00800;    /* ETXTBSY */
        MAP_EXECUTABLE = 0x01000;   /* Mark it as an executable.  */
        MAP_LOCKED = 0x02000;       /* Lock the mapping.  */
        MAP_NORESERVE = 0x04000;    /* Don't check for reservations.  */
        MAP_POPULATE = 0x08000;     /* Populate (prefault) pagetables.  */
        MAP_NONBLOCK = 0x10000;     /* Do not block on IO.  */
        MAP_STACK = 0x20000;        /* Allocation is for a stack.  */
        MAP_HUGETLB = 0x40000;      /* Create huge page mapping.  */
    }
#endif

/************************************************************************
    sys/mman.h
************************************************************************/

/* Return value of `mmap' in case of an error.  */
define {
    MAP_FAILED = void(-1);
}

/************************************************************************
    bits/waitflags.h
************************************************************************/

define {
    /* Bits in the third argument to `waitpid'.  */
    WNOHANG = 1;                /* Don't block waiting.  */
    WUNTRACED = 2;              /* Report status of stopped children.  */
    /* Bits in the fourth argument to `waitid'.  */
    WSTOPPED = 2;               /* Report stopped child (same as WUNTRACED). */
    WEXITED = 4;                /* Report dead child.  */
    WCONTINUED = 8;             /* Report continued child.  */
    WNOWAIT = 0x01000000;       /* Don't reap, just poll status.  */
    __WNOTHREAD = 0x20000000;   /* Don't wait on children of other threads in this group */
    __WALL = 0x40000000;        /* Wait for any child.  */
    __WCLONE = 0x80000000;      /* Wait for cloned process.  */
}

/************************************************************************
    bits/waitstatus.h
************************************************************************/

/* If WIFEXITED(STATUS), the low-order 8 bits of the status.  */
inline __WEXITSTATUS(status int) int {
    return (status & 0xff00) >> 8;
}

/* If WIFSIGNALED(STATUS), the terminating signal.  */
inline __WTERMSIG(status int) int {
    return status & 0x7f;
}

/* If WIFSTOPPED(STATUS), the signal that stopped the child.  */
inline __WSTOPSIG(status int) int {
    return __WEXITSTATUS(status);
}

/* Nonzero if STATUS indicates normal termination.  */
inline __WIFEXITED(status int) int {
    return __WTERMSIG(status) == 0;
}

/* Nonzero if STATUS indicates termination by a signal.  */
inline __WIFSIGNALED(status int) int {
    return (char((status & 0x7f) + 1) >> 1) > 0;
}

/* Nonzero if STATUS indicates the child is stopped.  */
inline __WIFSTOPPED(status int) int {
    return (status & 0xff) == 0x7f;
}

/* Nonzero if STATUS indicates the child continued after a stop.  We only
   define this if <bits/waitflags.h> provides the WCONTINUED flag bit.  */
#if objectid(WCONTINUED);
    inline __WIFCONTINUED(status int) int {
        return status == __W_CONTINUED;
    }
#endif

/* Nonzero if STATUS indicates the child dumped core.  */
inline __WCOREDUMP(status int) int {
    return status & __WCOREFLAG;
}

/* Macros for constructing status values.  */
inline __W_EXITCODE(ret int, sig int) int {
    return ret << 8 | sig;
}
inline __W_STOPCODE(sig int) int {
    return sig << 8 | 0x7f;
}

define {
    __W_CONTINUED = 0xffff;
    __WCOREFLAG = 0x80;
}

/************************************************************************
    sys/wait.h
************************************************************************/

define {
    WEXITSTATUS = __WEXITSTATUS;
    WTERMSIG = __WTERMSIG;
    WSTOPSIG = __WSTOPSIG;
    WIFEXITED = __WIFEXITED;
    WIFSIGNALED = __WIFSIGNALED;
    WIFSTOPPED = __WIFSTOPPED;
#if objectid(__WIFCONTINUED);
    WIFCONTINUED = __WIFCONTINUED;
#endif
#if objectid(__USE_MISC);
    WCOREFLAG = __WCOREFLAG;
    WCOREDUMP = __WCOREDUMP;
    W_EXITCODE = __W_EXITCODE;
    W_STOPCODE = __W_STOPCODE;
#endif
}

/* The following values are used by the `waitid' function.  */
#if objectid(__USE_XOPEN) | objectid(__USE_XOPEN2K8);
    enum idtype_t;
    enum {
        P_ALL,      /* Wait for any child.  */
        P_PID,      /* Wait for specified process.  */
        P_PGID      /* Wait for members of process group.  */
    }
#endif

/************************************************************************
    bits/dlfcn.h
************************************************************************/

/* The MODE argument to `dlopen' contains one of the following: */
define {
    RTLD_LAZY = 0x00001;        /* Lazy function call binding.  */
    RTLD_NOW = 0x00002;         /* Immediate function call binding.  */
    RTLD_BINDING_MASK = 0x3;    /* Mask of binding time value.  */
    RTLD_NOLOAD = 0x00004;      /* Do not load the object.  */
    RTLD_DEEPBIND = 0x00008;    /* Use deep binding.  */
}

/* If the following bit is set in the MODE argument to `dlopen',
   the symbols of the loaded object and its dependencies are made
   visible as if the object were linked directly into the program.  */
define {
    RTLD_GLOBAL = 0x00100;
}

/* Unix98 demands the following flag which is the inverse to RTLD_GLOBAL.
   The implementation does this by default and so we can define the
   value to zero.  */
define {
    RTLD_LOCAL = 0;
}

/* Do not delete object when closed.  */
define {
    RTLD_NODELETE = 0x01000;
}

/************************************************************************
    pthread.h
************************************************************************/

/* Detach state.  */
enum {
    PTHREAD_CREATE_JOINABLE,
    PTHREAD_CREATE_DETACHED
}

/* Mutex types.  */
enum {
    PTHREAD_MUTEX_TIMED_NP,
    PTHREAD_MUTEX_RECURSIVE_NP,
    PTHREAD_MUTEX_ERRORCHECK_NP,
    PTHREAD_MUTEX_ADAPTIVE_NP,
#if objectid(__USE_UNIX98) | objectid(__USE_XOPEN2K8);
    PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
    PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
    PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
    PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL,
#endif
#if objectid(__USE_GNU);
    /* For compatibility.  */
    PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP,
#endif
}

#if objectid(__USE_XOPEN2K);
    /* Robust mutex or not flags.  */
    enum {
        PTHREAD_MUTEX_STALLED,
        PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
        PTHREAD_MUTEX_ROBUST,
        PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
    }
#endif

#if objectid(__USE_POSIX199506) | objectid(__USE_UNIX98);
    /* Mutex protocols.  */
    enum {
        PTHREAD_PRIO_NONE,
        PTHREAD_PRIO_INHERIT,
        PTHREAD_PRIO_PROTECT
    }
#endif

/************************************************************************
    pthreadtypes.h
************************************************************************/

/* Thread identifiers.  The structure of the attribute type is not
   exposed on purpose.  */
typedef pthread_t unsigned long;

define {
    __SIZEOF_PTHREAD_ATTR_T = 36;
    __SIZEOF_PTHREAD_MUTEX_T = 24;
    __SIZEOF_PTHREAD_MUTEXATTR_T = 4;
    __SIZEOF_PTHREAD_COND_T = 48;
    __SIZEOF_PTHREAD_COND_COMPAT_T = 12;
    __SIZEOF_PTHREAD_CONDATTR_T = 4;
    __SIZEOF_PTHREAD_RWLOCK_T = 32;
    __SIZEOF_PTHREAD_RWLOCKATTR_T = 8;
    __SIZEOF_PTHREAD_BARRIER_T = 20;
    __SIZEOF_PTHREAD_BARRIERATTR_T = 4;
}

union pthread_attr_t {
    __size(__SIZEOF_PTHREAD_ATTR_T) char;
    __align long;
}

struct __pthread_slist_t {
    __next. __pthread_slist_t;
}

/* Data structures for mutex handling.  The structure of the attribute
   type is not exposed on purpose.  */
union pthread_mutex_t {
    struct __data {
        __lock int;
        __count unsigned int;
        __owner int;
        /* KIND must stay at this position in the structure to maintain
            binary compatibility with static initializers.  */
        __kind int;
        __nusers unsigned int;
        union union1 {
            __spins int;
            __list __pthread_slist_t;
        }
    }
    __size(__SIZEOF_PTHREAD_MUTEX_T) char;
    __align long;
}

/* Mutex __spins initializer used by PTHREAD_MUTEX_INITIALIZER.  */
define {
    __PTHREAD_SPINS = 0;
}

union pthread_mutexattr_t {
    __size(__SIZEOF_PTHREAD_MUTEXATTR_T) char;
    __align long;
}

/* Data structure for conditional variable handling.  The structure of
   the attribute type is not exposed on purpose.  */
union pthread_cond_t {
    struct __data {
        union union1 {
            __wseq unsigned dlong;
            struct __wseq32 {
                __low unsigned int;
                __high unsigned int;
            }
        }
        union union2 {
            __g1_start unsigned dlong;
            struct __g1_start32 {
                __low unsigned int;
                __high unsigned int;
            }
        }
        __g_refs(2) unsigned int;
        __g_size(2) unsigned int;
        __g1_orig_size unsigned int;
        __wrefs unsigned int;
        __g_signals(2) unsigned int;
    }
    __size(__SIZEOF_PTHREAD_COND_T) char;
    __align dlong;
}

union pthread_condattr_t {
    __size(__SIZEOF_PTHREAD_CONDATTR_T) char;
    __align long;
}

/* Keys for thread-specific data */
typedef pthread_key_t unsigned int;

/* Once-only execution */
typedef pthread_once_t int;

#if objectid(__USE_UNIX98) | objectid(__USE_XOPEN2K);
    /* Data structure for read-write lock variable handling.  The
        structure of the attribute type is not exposed on purpose.  */
    union pthread_rwlock_t {
        struct __data {
            __readers unsigned int;
            __writers unsigned int;
            __wrphase_futex unsigned int;
            __writers_futex unsigned int;
            __pad3 unsigned int;
            __pad4 unsigned int;
            #if __BYTE_ORDER == __BIG_ENDIAN;
                __pad1 unsigned char;
                __pad2 unsigned char;
                __shared unsigned char;
                /* FLAGS must stay at this position in the structure to maintain
                    binary compatibility.  */
                __flags unsigned char;
            #else
                /* FLAGS must stay at this position in the structure to maintain
                    binary compatibility.  */
                __flags unsigned char;
                __shared unsigned char;
                __pad1 unsigned char;
                __pad2 unsigned char;
            #endif
            __cur_writer int;
        }
        __size(__SIZEOF_PTHREAD_RWLOCK_T) char;
        __align long;
    }

    define {
        __PTHREAD_RWLOCK_ELISION_EXTRA = 0;
    }

    union pthread_rwlockattr_t {
        __size(__SIZEOF_PTHREAD_RWLOCKATTR_T) char;
        __align long;
    }
#endif

#if objectid(__USE_XOPEN2K);
    /* POSIX spinlock data type.  */
    typedef pthread_spinlock_t int;

    /* POSIX barriers data type.  The structure of the type is
        deliberately not exposed.  */
    union pthread_barrier_t {
        __size(__SIZEOF_PTHREAD_BARRIER_T) char;
        __align long;
    }

    union pthread_barrierattr_t {
        __size(__SIZEOF_PTHREAD_BARRIERATTR_T) char;
        __align int;
    }
#endif

/************************************************************************
    eof
************************************************************************/

}
