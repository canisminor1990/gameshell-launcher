
// 2.0.9.0

module lib+ {

    module sdl2+ {

        module so {

            struct struct {
                // SDL.h
                SDL_Init void;
                SDL_Quit void;
                // SDL_error.h
                SDL_SetError void;
                SDL_GetError void;
                SDL_ClearError void;
                SDL_Error void;
                // SDL_hints.h
                SDL_SetHint void;
                SDL_GetHint void;
                // SDL_rect.h
                SDL_HasIntersection void;
                SDL_IntersectRect void;
                SDL_UnionRect void;
                SDL_EnclosePoints void;
                SDL_IntersectRectAndLine void;
                // SDL_timer.h
                SDL_GetTicks void;
                SDL_GetPerformanceCounter void;
                SDL_GetPerformanceFrequency void;
                SDL_Delay void;
                SDL_AddTimer void;
                SDL_RemoveTimer void;
                // SDL_rwops.h
                SDL_RWFromFile void;
                SDL_RWFromFP void;
                SDL_RWFromMem void;
                SDL_RWFromConstMem void;
                SDL_AllocRW void;
                SDL_FreeRW void;
                // SDL_video.h
                SDL_GL_GetProcAddress void;
                SDL_GetNumVideoDrivers void;
                SDL_GetVideoDriver void;
                SDL_VideoInit void;
                SDL_VideoQuit void;
                SDL_GetCurrentVideoDriver void;
                SDL_GetNumVideoDisplays void;
                SDL_GetDisplayName void;
                SDL_GetDisplayBounds void;
                SDL_GetDisplayUsableBounds void;
                SDL_GetDisplayDPI void;
                SDL_GetNumDisplayModes void;
                SDL_GetDisplayMode void;
                SDL_GetDesktopDisplayMode void;
                SDL_GetCurrentDisplayMode void;
                SDL_GetClosestDisplayMode void;
                SDL_GetWindowDisplayIndex void;
                SDL_SetWindowDisplayMode void;
                SDL_GetWindowDisplayMode void;
                SDL_GetWindowPixelFormat void;
                SDL_CreateWindow void;
                SDL_CreateWindowFrom void;
                SDL_DestroyWindow void;
                SDL_GetWindowID void;
                SDL_GetWindowFromID void;
                SDL_GetWindowFlags void;
                SDL_SetWindowTitle void;
                SDL_GetWindowTitle void;
                SDL_SetWindowIcon void;
                SDL_SetWindowData void;
                SDL_GetWindowData void;
                SDL_SetWindowPosition void;
                SDL_GetWindowPosition void;
                SDL_SetWindowSize void;
                SDL_GetWindowSize void;
                SDL_GetWindowBordersSize void;
                SDL_SetWindowMinimumSize void;
                SDL_GetWindowMinimumSize void;
                SDL_SetWindowMaximumSize void;
                SDL_GetWindowMaximumSize void;
                SDL_SetWindowBordered void;
                SDL_SetWindowResizable void;
                SDL_ShowWindow void;
                SDL_HideWindow void;
                SDL_RaiseWindow void;
                SDL_MaximizeWindow void;
                SDL_MinimizeWindow void;
                SDL_RestoreWindow void;
                SDL_SetWindowFullscreen void;
                SDL_GetWindowSurface void;
                SDL_UpdateWindowSurface void;
                SDL_UpdateWindowSurfaceRects void;
                SDL_SetWindowGrab void;
                SDL_GetWindowGrab void;
                SDL_GetGrabbedWindow void;
                SDL_SetWindowBrightness void;
                SDL_GetWindowBrightness void;
                SDL_SetWindowOpacity void;
                SDL_GetWindowOpacity void;
                SDL_SetWindowModalFor void;
                SDL_SetWindowInputFocus void;
                SDL_SetWindowGammaRamp void;
                SDL_GetWindowGammaRamp void;
                SDL_SetWindowHitTest void;
                SDL_IsScreenSaverEnabled void;
                SDL_EnableScreenSaver void;
                SDL_DisableScreenSaver void;
                // SDL_keyboard.h
                SDL_GetKeyboardFocus void;
                SDL_GetKeyboardState void;
                SDL_GetModState void;
                SDL_SetModState void;
                SDL_GetKeyFromScancode void;
                SDL_GetScancodeFromKey void;
                SDL_GetScancodeName void;
                SDL_GetScancodeFromName void;
                SDL_GetKeyName void;
                SDL_GetKeyFromName void;
                SDL_StartTextInput void;
                SDL_IsTextInputActive void;
                SDL_StopTextInput void;
                SDL_SetTextInputRect void;
                SDL_HasScreenKeyboardSupport void;
                SDL_IsScreenKeyboardShown void;
                // SDL_mouse.h
                SDL_GetMouseFocus void;
                SDL_GetMouseState void;
                SDL_GetGlobalMouseState void;
                SDL_GetRelativeMouseState void;
                SDL_WarpMouseInWindow void;
                SDL_WarpMouseGlobal void;
                SDL_SetRelativeMouseMode void;
                SDL_CaptureMouse void;
                SDL_GetRelativeMouseMode void;
                SDL_CreateCursor void;
                SDL_CreateColorCursor void;
                SDL_CreateSystemCursor void;
                SDL_SetCursor void;
                SDL_GetCursor void;
                SDL_GetDefaultCursor void;
                SDL_FreeCursor void;
                SDL_ShowCursor void;
                // SDL_events.h
                SDL_PumpEvents void;
                SDL_PeepEvents void;
                SDL_HasEvent void;
                SDL_HasEvents void;
                SDL_FlushEvent void;
                SDL_FlushEvents void;
                SDL_PollEvent void;
                SDL_WaitEvent void;
                SDL_WaitEventTimeout void;
                SDL_PushEvent void;
                SDL_SetEventFilter void;
                SDL_GetEventFilter void;
                SDL_AddEventWatch void;
                SDL_DelEventWatch void;
                SDL_FilterEvents void;
                SDL_EventState void;
                SDL_RegisterEvents void;
                // SDL_render.h
                SDL_GetNumRenderDrivers void;
                SDL_GetRenderDriverInfo void;
                SDL_CreateRenderer void;
                SDL_DestroyRenderer void;
                SDL_GetRenderer void;
                SDL_GetRendererInfo void;
                SDL_CreateTexture void;
                SDL_CreateTextureFromSurface void;
                SDL_DestroyTexture void;
                SDL_QueryTexture void;
                SDL_SetTextureColorMod void;
                SDL_GetTextureColorMod void;
                SDL_SetTextureAlphaMod void;
                SDL_GetTextureAlphaMod void;
                SDL_SetTextureBlendMode void;
                SDL_GetTextureBlendMode void;
                SDL_UpdateTexture void;
                SDL_UpdateYUVTexture void;
                SDL_LockTexture void;
                SDL_UnlockTexture void;
                SDL_RenderTargetSupported void;
                SDL_SetRenderTarget void;
                SDL_GetRenderTarget void;
                SDL_RenderSetLogicalSize void;
                SDL_RenderGetLogicalSize void;
                SDL_RenderSetIntegerScale void;
                SDL_RenderGetIntegerScale void;
                SDL_RenderSetViewport void;
                SDL_RenderGetViewport void;
                SDL_RenderSetClipRect void;
                SDL_RenderGetClipRect void;
                SDL_RenderIsClipEnabled void;
                SDL_RenderSetScale void;
                SDL_RenderGetScale void;
                SDL_SetRenderDrawColor void;
                SDL_GetRenderDrawColor void;
                SDL_SetRenderDrawBlendMode void;
                SDL_GetRenderDrawBlendMode void;
                SDL_RenderClear void;
                SDL_RenderDrawPoint void;
                SDL_RenderDrawPoints void;
                SDL_RenderDrawLine void;
                SDL_RenderDrawLines void;
                SDL_RenderDrawRect void;
                SDL_RenderDrawRects void;
                SDL_RenderFillRect void;
                SDL_RenderFillRects void;
                SDL_RenderCopy void;
                SDL_RenderCopyEx void;
                SDL_RenderReadPixels void;
                SDL_RenderPresent void;
                // SDL_pixels.h
                SDL_GetPixelFormatName void;
                SDL_PixelFormatEnumToMasks void;
                SDL_MasksToPixelFormatEnum void;
                SDL_AllocFormat void;
                SDL_FreeFormat void;
                SDL_AllocPalette void;
                SDL_SetPixelFormatPalette void;
                SDL_SetPaletteColors void;
                SDL_FreePalette void;
                SDL_MapRGB void;
                SDL_MapRGBA void;
                SDL_GetRGB void;
                SDL_GetRGBA void;
                SDL_CalculateGammaRamp void;
                // SDL_surface.h
                SDL_CreateRGBSurface void;
                SDL_CreateRGBSurfaceWithFormat void;
                SDL_CreateRGBSurfaceFrom void;
                SDL_CreateRGBSurfaceWithFormatFrom void;
                SDL_FreeSurface void;
                SDL_SetSurfacePalette void;
                SDL_LockSurface void;
                SDL_UnlockSurface void;
                SDL_SetSurfaceRLE void;
                SDL_SetColorKey void;
                SDL_GetColorKey void;
                SDL_SetSurfaceColorMod void;
                SDL_GetSurfaceColorMod void;
                SDL_SetSurfaceAlphaMod void;
                SDL_GetSurfaceAlphaMod void;
                SDL_SetSurfaceBlendMode void;
                SDL_GetSurfaceBlendMode void;
                SDL_SetClipRect void;
                SDL_GetClipRect void;
                SDL_ConvertSurface void;
                SDL_ConvertSurfaceFormat void;
                SDL_ConvertPixels void;
                SDL_FillRect void;
                SDL_FillRects void;
                SDL_UpperBlit void; // SDL_BlitSurface
                SDL_LowerBlit void;
                SDL_SoftStretch void;
                SDL_UpperBlitScaled void; // SDL_BlitScaled
                SDL_LowerBlitScaled void;
            }

            var fn struct;

            func init() bool {
                import rt::c;
                return dlsyms(dlopen("libSDL2-2.0.so.0", RTLD_LAZY), &fn,
                    // SDL.h
                    "SDL_Init",
                    "SDL_Quit",
                    // SDL_error.h
                    "SDL_SetError",
                    "SDL_GetError",
                    "SDL_ClearError", 
                    "SDL_Error",
                    // SDL_hints.h
                    "SDL_SetHint",
                    "SDL_GetHint",
                    // SDL_rect.h
                    "SDL_HasIntersection",
                    "SDL_IntersectRect",
                    "SDL_UnionRect",
                    "SDL_EnclosePoints",
                    "SDL_IntersectRectAndLine",
                    // SDL_timer.h
                    "SDL_GetTicks",
                    "SDL_GetPerformanceCounter",
                    "SDL_GetPerformanceFrequency",
                    "SDL_Delay",
                    "SDL_AddTimer",
                    "SDL_RemoveTimer",
                    // SDL_rwops.h
                    "SDL_RWFromFile",
                    "SDL_RWFromFP",
                    "SDL_RWFromMem",
                    "SDL_RWFromConstMem",
                    "SDL_AllocRW",
                    "SDL_FreeRW",
                    // SDL_video.h
                    "SDL_GL_GetProcAddress",
                    "SDL_GetNumVideoDrivers",
                    "SDL_GetVideoDriver",
                    "SDL_VideoInit",
                    "SDL_VideoQuit",
                    "SDL_GetCurrentVideoDriver",
                    "SDL_GetNumVideoDisplays",
                    "SDL_GetDisplayName",
                    "SDL_GetDisplayBounds",
                    "SDL_GetDisplayUsableBounds",
                    "SDL_GetDisplayDPI",
                    "SDL_GetNumDisplayModes",
                    "SDL_GetDisplayMode",
                    "SDL_GetDesktopDisplayMode",
                    "SDL_GetCurrentDisplayMode",
                    "SDL_GetClosestDisplayMode",
                    "SDL_GetWindowDisplayIndex",
                    "SDL_SetWindowDisplayMode",
                    "SDL_GetWindowDisplayMode",
                    "SDL_GetWindowPixelFormat",
                    "SDL_CreateWindow",
                    "SDL_CreateWindowFrom",
                    "SDL_DestroyWindow",
                    "SDL_GetWindowID",
                    "SDL_GetWindowFromID",
                    "SDL_GetWindowFlags",
                    "SDL_SetWindowTitle",
                    "SDL_GetWindowTitle",
                    "SDL_SetWindowIcon",
                    "SDL_SetWindowData",
                    "SDL_GetWindowData",
                    "SDL_SetWindowPosition",
                    "SDL_GetWindowPosition",
                    "SDL_SetWindowSize",
                    "SDL_GetWindowSize",
                    "SDL_GetWindowBordersSize",
                    "SDL_SetWindowMinimumSize",
                    "SDL_GetWindowMinimumSize",
                    "SDL_SetWindowMaximumSize",
                    "SDL_GetWindowMaximumSize",
                    "SDL_SetWindowBordered",
                    "SDL_SetWindowResizable",
                    "SDL_ShowWindow",
                    "SDL_HideWindow",
                    "SDL_RaiseWindow",
                    "SDL_MaximizeWindow",
                    "SDL_MinimizeWindow",
                    "SDL_RestoreWindow",
                    "SDL_SetWindowFullscreen",
                    "SDL_GetWindowSurface",
                    "SDL_UpdateWindowSurface",
                    "SDL_UpdateWindowSurfaceRects",
                    "SDL_SetWindowGrab",
                    "SDL_GetWindowGrab",
                    "SDL_GetGrabbedWindow",
                    "SDL_SetWindowBrightness",
                    "SDL_GetWindowBrightness",
                    "SDL_SetWindowOpacity",
                    "SDL_GetWindowOpacity",
                    "SDL_SetWindowModalFor",
                    "SDL_SetWindowInputFocus",
                    "SDL_SetWindowGammaRamp",
                    "SDL_GetWindowGammaRamp",
                    "SDL_SetWindowHitTest",
                    "SDL_IsScreenSaverEnabled",
                    "SDL_EnableScreenSaver",
                    "SDL_DisableScreenSaver",
                    // SDL_keyboard.h
                    "SDL_GetKeyboardFocus",
                    "SDL_GetKeyboardState",
                    "SDL_GetModState",
                    "SDL_SetModState",
                    "SDL_GetKeyFromScancode",
                    "SDL_GetScancodeFromKey",
                    "SDL_GetScancodeName",
                    "SDL_GetScancodeFromName",
                    "SDL_GetKeyName",
                    "SDL_GetKeyFromName",
                    "SDL_StartTextInput",
                    "SDL_IsTextInputActive",
                    "SDL_StopTextInput",
                    "SDL_SetTextInputRect",
                    "SDL_HasScreenKeyboardSupport",
                    "SDL_IsScreenKeyboardShown",
                    // SDL_mouse.h
                    "SDL_GetMouseFocus",
                    "SDL_GetMouseState",
                    "SDL_GetGlobalMouseState",
                    "SDL_GetRelativeMouseState",
                    "SDL_WarpMouseInWindow",
                    "SDL_WarpMouseGlobal",
                    "SDL_SetRelativeMouseMode",
                    "SDL_CaptureMouse",
                    "SDL_GetRelativeMouseMode",
                    "SDL_CreateCursor",
                    "SDL_CreateColorCursor",
                    "SDL_CreateSystemCursor",
                    "SDL_SetCursor",
                    "SDL_GetCursor",
                    "SDL_GetDefaultCursor",
                    "SDL_FreeCursor",
                    "SDL_ShowCursor",
                    // SDL_events.h
                    "SDL_PumpEvents",
                    "SDL_PeepEvents",
                    "SDL_HasEvent",
                    "SDL_HasEvents",
                    "SDL_FlushEvent",
                    "SDL_FlushEvents",
                    "SDL_PollEvent",
                    "SDL_WaitEvent",
                    "SDL_WaitEventTimeout",
                    "SDL_PushEvent",
                    "SDL_SetEventFilter",
                    "SDL_GetEventFilter",
                    "SDL_AddEventWatch",
                    "SDL_DelEventWatch",
                    "SDL_FilterEvents",
                    "SDL_EventState",
                    "SDL_RegisterEvents",
                    // SDL_render.h
                    "SDL_GetNumRenderDrivers",
                    "SDL_GetRenderDriverInfo",
                    "SDL_CreateRenderer",
                    "SDL_DestroyRenderer",
                    "SDL_GetRenderer",
                    "SDL_GetRendererInfo",
                    "SDL_CreateTexture",
                    "SDL_CreateTextureFromSurface",
                    "SDL_DestroyTexture",
                    "SDL_QueryTexture",
                    "SDL_SetTextureColorMod",
                    "SDL_GetTextureColorMod",
                    "SDL_SetTextureAlphaMod",
                    "SDL_GetTextureAlphaMod",
                    "SDL_SetTextureBlendMode",
                    "SDL_GetTextureBlendMode",
                    "SDL_UpdateTexture",
                    "SDL_UpdateYUVTexture",
                    "SDL_LockTexture",
                    "SDL_UnlockTexture",
                    "SDL_RenderTargetSupported",
                    "SDL_SetRenderTarget",
                    "SDL_GetRenderTarget",
                    "SDL_RenderSetLogicalSize",
                    "SDL_RenderGetLogicalSize",
                    "SDL_RenderSetIntegerScale",
                    "SDL_RenderGetIntegerScale",
                    "SDL_RenderSetViewport",
                    "SDL_RenderGetViewport",
                    "SDL_RenderSetClipRect",
                    "SDL_RenderGetClipRect",
                    "SDL_RenderIsClipEnabled",
                    "SDL_RenderSetScale",
                    "SDL_RenderGetScale",
                    "SDL_SetRenderDrawColor",
                    "SDL_GetRenderDrawColor",
                    "SDL_SetRenderDrawBlendMode",
                    "SDL_GetRenderDrawBlendMode",
                    "SDL_RenderClear",
                    "SDL_RenderDrawPoint",
                    "SDL_RenderDrawPoints",
                    "SDL_RenderDrawLine",
                    "SDL_RenderDrawLines",
                    "SDL_RenderDrawRect",
                    "SDL_RenderDrawRects",
                    "SDL_RenderFillRect",
                    "SDL_RenderFillRects",
                    "SDL_RenderCopy",
                    "SDL_RenderCopyEx",
                    "SDL_RenderReadPixels",
                    "SDL_RenderPresent",
                    // SDL_pixels.h
                    "SDL_GetPixelFormatName",
                    "SDL_PixelFormatEnumToMasks",
                    "SDL_MasksToPixelFormatEnum",
                    "SDL_AllocFormat",
                    "SDL_FreeFormat",
                    "SDL_AllocPalette",
                    "SDL_SetPixelFormatPalette",
                    "SDL_SetPaletteColors",
                    "SDL_FreePalette",
                    "SDL_MapRGB",
                    "SDL_MapRGBA",
                    "SDL_GetRGB",
                    "SDL_GetRGBA",
                    "SDL_CalculateGammaRamp",
                    // SDL_surface.h
                    "SDL_CreateRGBSurface",
                    "SDL_CreateRGBSurfaceWithFormat",
                    "SDL_CreateRGBSurfaceFrom",
                    "SDL_CreateRGBSurfaceWithFormatFrom",
                    "SDL_FreeSurface",
                    "SDL_SetSurfacePalette",
                    "SDL_LockSurface",
                    "SDL_UnlockSurface",
                    "SDL_SetSurfaceRLE",
                    "SDL_SetColorKey",
                    "SDL_GetColorKey",
                    "SDL_SetSurfaceColorMod",
                    "SDL_GetSurfaceColorMod",
                    "SDL_SetSurfaceAlphaMod",
                    "SDL_GetSurfaceAlphaMod",
                    "SDL_SetSurfaceBlendMode",
                    "SDL_GetSurfaceBlendMode",
                    "SDL_SetClipRect",
                    "SDL_GetClipRect",
                    "SDL_ConvertSurface",
                    "SDL_ConvertSurfaceFormat",
                    "SDL_ConvertPixels",
                    "SDL_FillRect",
                    "SDL_FillRects",
                    "SDL_UpperBlit",
                    "SDL_LowerBlit",
                    "SDL_SoftStretch",
                    "SDL_UpperBlitScaled",
                    "SDL_LowerBlitScaled"
                );
            }

        }

    }

    module sdl2+ {

        private import rt::c;

        // SDL.h

        define {
            SDL_INIT_TIMER = uint(0x00000001);
            SDL_INIT_AUDIO = uint(0x00000010);
            SDL_INIT_VIDEO = uint(0x00000020);  /**< SDL_INIT_VIDEO implies SDL_INIT_EVENTS */
            SDL_INIT_JOYSTICK = uint(0x00000200);  /**< SDL_INIT_JOYSTICK implies SDL_INIT_EVENTS */
            SDL_INIT_HAPTIC = uint(0x00001000);
            SDL_INIT_GAMECONTROLLER = uint(0x00002000);  /**< SDL_INIT_GAMECONTROLLER implies SDL_INIT_JOYSTICK */
            SDL_INIT_EVENTS = uint(0x00004000);
            SDL_INIT_SENSOR = uint(0x00008000);
            SDL_INIT_NOPARACHUTE = uint(0x00100000);  /**< compatibility; this flag is ignored. */
            SDL_INIT_EVERYTHING = (
                SDL_INIT_TIMER | SDL_INIT_AUDIO | SDL_INIT_VIDEO | SDL_INIT_EVENTS |
                SDL_INIT_JOYSTICK | SDL_INIT_HAPTIC | SDL_INIT_GAMECONTROLLER | SDL_INIT_SENSOR
                );
        }

        // SDL_stdinc.h

        define {
            SDL_FALSE = 0;
            SDL_TRUE = 1;
        }

        typedef SDL_bool int;

        // SDL_error.h

        enum SDL_errorcode;
        enum {
            SDL_ENOMEM,
            SDL_EFREAD,
            SDL_EFWRITE,
            SDL_EFSEEK,
            SDL_UNSUPPORTED,
            SDL_LASTERROR
        }

        // SDL_hints.h

        define {
            SDL_HINT_RENDER_DRIVER = "SDL_RENDER_DRIVER";
        }

        // SDL_rect.h

        struct SDL_Point {
            x int;
            y int;
        }

        struct SDL_Rect {
            x int, y int;
            w int, h int;
        }

        // SDL_blendmode.h

        enum SDL_BlendMode;
        enum {
            SDL_BLENDMODE_NONE = 0x00000000,     /**< no blending
                dstRGBA = srcRGBA */
            SDL_BLENDMODE_BLEND = 0x00000001,    /**< alpha blending
                dstRGB = (srcRGB * srcA) + (dstRGB * (1-srcA))
                dstA = srcA + (dstA * (1-srcA)) */
            SDL_BLENDMODE_ADD = 0x00000002,      /**< additive blending
                dstRGB = (srcRGB * srcA) + dstRGB
                dstA = dstA */
            SDL_BLENDMODE_MOD = 0x00000004,      /**< color modulate
                dstRGB = srcRGB * dstRGB
                dstA = dstA */
            SDL_BLENDMODE_INVALID = 0x7FFFFFFF
            /* Additional custom blend modes can be returned by SDL_ComposeCustomBlendMode() */
        }

        enum SDL_BlendOperation;
        enum {
            SDL_BLENDOPERATION_ADD              = 0x1,  /**< dst + src: supported by all renderers */
            SDL_BLENDOPERATION_SUBTRACT         = 0x2,  /**< dst - src : supported by D3D9, D3D11, OpenGL, OpenGLES */
            SDL_BLENDOPERATION_REV_SUBTRACT     = 0x3,  /**< src - dst : supported by D3D9, D3D11, OpenGL, OpenGLES */
            SDL_BLENDOPERATION_MINIMUM          = 0x4,  /**< min(dst, src) : supported by D3D11 */
            SDL_BLENDOPERATION_MAXIMUM          = 0x5   /**< max(dst, src) : supported by D3D11 */
        }

        enum SDL_BlendFactor;
        enum {
            SDL_BLENDFACTOR_ZERO                = 0x1,  /**< 0, 0, 0, 0 */
            SDL_BLENDFACTOR_ONE                 = 0x2,  /**< 1, 1, 1, 1 */
            SDL_BLENDFACTOR_SRC_COLOR           = 0x3,  /**< srcR, srcG, srcB, srcA */
            SDL_BLENDFACTOR_ONE_MINUS_SRC_COLOR = 0x4,  /**< 1-srcR, 1-srcG, 1-srcB, 1-srcA */
            SDL_BLENDFACTOR_SRC_ALPHA           = 0x5,  /**< srcA, srcA, srcA, srcA */
            SDL_BLENDFACTOR_ONE_MINUS_SRC_ALPHA = 0x6,  /**< 1-srcA, 1-srcA, 1-srcA, 1-srcA */
            SDL_BLENDFACTOR_DST_COLOR           = 0x7,  /**< dstR, dstG, dstB, dstA */
            SDL_BLENDFACTOR_ONE_MINUS_DST_COLOR = 0x8,  /**< 1-dstR, 1-dstG, 1-dstB, 1-dstA */
            SDL_BLENDFACTOR_DST_ALPHA           = 0x9,  /**< dstA, dstA, dstA, dstA */
            SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA = 0xA   /**< 1-dstA, 1-dstA, 1-dstA, 1-dstA */
        }

        // SDL_timer.h

        typedef SDL_TimerID int;

        // SDL_rwops.h

        define {
            SDL_RWOPS_UNKNOWN = uint(0);  /**< Unknown stream type */
            SDL_RWOPS_WINFILE = uint(1);  /**< Win32 file */
            SDL_RWOPS_STDFILE = uint(2);  /**< Stdio file */
            SDL_RWOPS_JNIFILE = uint(3);  /**< Android asset */
            SDL_RWOPS_MEMORY = uint(4);  /**< Memory stream */
            SDL_RWOPS_MEMORY_RO = uint(5);  /**< Read-Only memory stream */
        }

        struct SDL_RWops {
            size void;
            seek void;
            read void;
            write void;
            close void;
            type uint32;
            union hidden {
                #if objectid(__WIN32__);
                    struct windowsio {
                        append SDL_bool;
                        h void;
                        struct buffer {
                            data void;
                            size size_t;
                            left size_t;
                        }
                    }
                #endif
                // HAVE_STDIO_H
                struct stdio {
                    autoclose SDL_bool;
                    fp+ FILE;
                }
                struct mem {
                    base. uint8;
                    here. uint8;
                    stop. uint8;
                }
                struct unknown {
                    data1 void;
                    data2 void;
                }
            }
        }

        define {
            RW_SEEK_SET = 0;       /**< Seek from the beginning of data */
            RW_SEEK_CUR = 1;       /**< Seek relative to current read point */
            RW_SEEK_END = 2;       /**< Seek relative to the end of data */
        }

        // SDL_video.h

        struct SDL_DisplayMode {
            format uint32;              /**< pixel format */
            w int;                      /**< width, in screen coordinates */
            h int;                      /**< height, in screen coordinates */
            refresh_rate int;           /**< refresh rate (or zero for unspecified) */
            driverdata void;           /**< driver-specific data, initialize to 0 */
        }

        enum SDL_WindowFlags;
        enum {
            /* !!! FIXME: change this to name = (1<<x). */
            SDL_WINDOW_FULLSCREEN = 0x00000001,         /**< fullscreen window */
            SDL_WINDOW_OPENGL = 0x00000002,             /**< window usable with OpenGL context */
            SDL_WINDOW_SHOWN = 0x00000004,              /**< window is visible */
            SDL_WINDOW_HIDDEN = 0x00000008,             /**< window is not visible */
            SDL_WINDOW_BORDERLESS = 0x00000010,         /**< no window decoration */
            SDL_WINDOW_RESIZABLE = 0x00000020,          /**< window can be resized */
            SDL_WINDOW_MINIMIZED = 0x00000040,          /**< window is minimized */
            SDL_WINDOW_MAXIMIZED = 0x00000080,          /**< window is maximized */
            SDL_WINDOW_INPUT_GRABBED = 0x00000100,      /**< window has grabbed input focus */
            SDL_WINDOW_INPUT_FOCUS = 0x00000200,        /**< window has input focus */
            SDL_WINDOW_MOUSE_FOCUS = 0x00000400,        /**< window has mouse focus */
            SDL_WINDOW_FULLSCREEN_DESKTOP = ( SDL_WINDOW_FULLSCREEN | 0x00001000 ),
            SDL_WINDOW_FOREIGN = 0x00000800,            /**< window not created by SDL */
            SDL_WINDOW_ALLOW_HIGHDPI = 0x00002000,      /**< window should be created in high-DPI mode if supported.
                                                            On macOS NSHighResolutionCapable must be set true in the
                                                            application's Info.plist for this to have any effect. */
            SDL_WINDOW_MOUSE_CAPTURE = 0x00004000,      /**< window has mouse captured (unrelated to INPUT_GRABBED) */
            SDL_WINDOW_ALWAYS_ON_TOP = 0x00008000,      /**< window should always be above others */
            SDL_WINDOW_SKIP_TASKBAR  = 0x00010000,      /**< window should not be added to the taskbar */
            SDL_WINDOW_UTILITY       = 0x00020000,      /**< window should be treated as a utility window */
            SDL_WINDOW_TOOLTIP       = 0x00040000,      /**< window should be treated as a tooltip */
            SDL_WINDOW_POPUP_MENU    = 0x00080000,      /**< window should be treated as a popup menu */
            SDL_WINDOW_VULKAN        = 0x10000000       /**< window usable for Vulkan surface */
        }

        define {
            SDL_WINDOWPOS_UNDEFINED_MASK = uint(0x1FFF0000);
            SDL_WINDOWPOS_UNDEFINED = SDL_WINDOWPOS_UNDEFINED_MASK;
        }

        inline SDL_WINDOWPOS_UNDEFINED_DISPLAY(X uint) uint {
            return SDL_WINDOWPOS_UNDEFINED_MASK | X;
        }

        inline SDL_WINDOWPOS_ISUNDEFINED(X uint) int {
            return (X & 0xFFFF0000) == SDL_WINDOWPOS_UNDEFINED_MASK;
        }

        define {
            SDL_WINDOWPOS_CENTERED_MASK = uint(0x2FFF0000);
            SDL_WINDOWPOS_CENTERED = SDL_WINDOWPOS_CENTERED_MASK;
        }

        inline SDL_WINDOWPOS_CENTERED_DISPLAY(X uint) uint {
            return SDL_WINDOWPOS_CENTERED_MASK | X;
        }

        inline SDL_WINDOWPOS_ISCENTERED(X uint) int {
            return (X & 0xFFFF0000) == SDL_WINDOWPOS_CENTERED_MASK;
        }

        enum SDL_WindowEventID;
        enum {
            SDL_WINDOWEVENT_NONE,           /**< Never used */
            SDL_WINDOWEVENT_SHOWN,          /**< Window has been shown */
            SDL_WINDOWEVENT_HIDDEN,         /**< Window has been hidden */
            SDL_WINDOWEVENT_EXPOSED,        /**< Window has been exposed and should be
                                                redrawn */
            SDL_WINDOWEVENT_MOVED,          /**< Window has been moved to data1, data2
                                            */
            SDL_WINDOWEVENT_RESIZED,        /**< Window has been resized to data1xdata2 */
            SDL_WINDOWEVENT_SIZE_CHANGED,   /**< The window size has changed, either as
                                                a result of an API call or through the
                                                system or user changing the window size. */
            SDL_WINDOWEVENT_MINIMIZED,      /**< Window has been minimized */
            SDL_WINDOWEVENT_MAXIMIZED,      /**< Window has been maximized */
            SDL_WINDOWEVENT_RESTORED,       /**< Window has been restored to normal size
                                                and position */
            SDL_WINDOWEVENT_ENTER,          /**< Window has gained mouse focus */
            SDL_WINDOWEVENT_LEAVE,          /**< Window has lost mouse focus */
            SDL_WINDOWEVENT_FOCUS_GAINED,   /**< Window has gained keyboard focus */
            SDL_WINDOWEVENT_FOCUS_LOST,     /**< Window has lost keyboard focus */
            SDL_WINDOWEVENT_CLOSE,          /**< The window manager requests that the window be closed */
            SDL_WINDOWEVENT_TAKE_FOCUS,     /**< Window is being offered a focus (should SetWindowInputFocus() on itself or a subwindow, or ignore) */
            SDL_WINDOWEVENT_HIT_TEST        /**< Window had a hit test that wasn't SDL_HITTEST_NORMAL. */
        }

        enum SDL_DisplayEventID;
        enum {
            SDL_DISPLAYEVENT_NONE,          /**< Never used */
            SDL_DISPLAYEVENT_ORIENTATION    /**< Display orientation has changed to data1 */
        }

        enum SDL_DisplayOrientation;
        enum {
            SDL_ORIENTATION_UNKNOWN,            /**< The display orientation can't be determined */
            SDL_ORIENTATION_LANDSCAPE,          /**< The display is in landscape mode, with the right side up, relative to portrait mode */
            SDL_ORIENTATION_LANDSCAPE_FLIPPED,  /**< The display is in landscape mode, with the left side up, relative to portrait mode */
            SDL_ORIENTATION_PORTRAIT,           /**< The display is in portrait mode */
            SDL_ORIENTATION_PORTRAIT_FLIPPED    /**< The display is in portrait mode, upside down */
        }

        enum SDL_GLattr;
        enum {
            SDL_GL_RED_SIZE,
            SDL_GL_GREEN_SIZE,
            SDL_GL_BLUE_SIZE,
            SDL_GL_ALPHA_SIZE,
            SDL_GL_BUFFER_SIZE,
            SDL_GL_DOUBLEBUFFER,
            SDL_GL_DEPTH_SIZE,
            SDL_GL_STENCIL_SIZE,
            SDL_GL_ACCUM_RED_SIZE,
            SDL_GL_ACCUM_GREEN_SIZE,
            SDL_GL_ACCUM_BLUE_SIZE,
            SDL_GL_ACCUM_ALPHA_SIZE,
            SDL_GL_STEREO,
            SDL_GL_MULTISAMPLEBUFFERS,
            SDL_GL_MULTISAMPLESAMPLES,
            SDL_GL_ACCELERATED_VISUAL,
            SDL_GL_RETAINED_BACKING,
            SDL_GL_CONTEXT_MAJOR_VERSION,
            SDL_GL_CONTEXT_MINOR_VERSION,
            SDL_GL_CONTEXT_EGL,
            SDL_GL_CONTEXT_FLAGS,
            SDL_GL_CONTEXT_PROFILE_MASK,
            SDL_GL_SHARE_WITH_CURRENT_CONTEXT,
            SDL_GL_FRAMEBUFFER_SRGB_CAPABLE,
            SDL_GL_CONTEXT_RELEASE_BEHAVIOR,
            SDL_GL_CONTEXT_RESET_NOTIFICATION,
            SDL_GL_CONTEXT_NO_ERROR
        }

        enum SDL_GLprofile;
        enum {
            SDL_GL_CONTEXT_PROFILE_CORE           = 0x0001,
            SDL_GL_CONTEXT_PROFILE_COMPATIBILITY  = 0x0002,
            SDL_GL_CONTEXT_PROFILE_ES             = 0x0004 /**< GLX_CONTEXT_ES2_PROFILE_BIT_EXT */
        }

        enum SDL_GLcontextFlag;
        enum {
            SDL_GL_CONTEXT_DEBUG_FLAG              = 0x0001,
            SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG = 0x0002,
            SDL_GL_CONTEXT_ROBUST_ACCESS_FLAG      = 0x0004,
            SDL_GL_CONTEXT_RESET_ISOLATION_FLAG    = 0x0008
        }

        enum SDL_GLcontextReleaseFlag;
        enum {
            SDL_GL_CONTEXT_RELEASE_BEHAVIOR_NONE   = 0x0000,
            SDL_GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH  = 0x0001
        }

        enum SDL_GLContextResetNotification;
        enum {
            SDL_GL_CONTEXT_RESET_NO_NOTIFICATION = 0x0000,
            SDL_GL_CONTEXT_RESET_LOSE_CONTEXT    = 0x0001
        }

        enum SDL_HitTestResult;
        enum {
            SDL_HITTEST_NORMAL,  /**< Region is normal. No special properties. */
            SDL_HITTEST_DRAGGABLE,  /**< Region can drag entire window. */
            SDL_HITTEST_RESIZE_TOPLEFT,
            SDL_HITTEST_RESIZE_TOP,
            SDL_HITTEST_RESIZE_TOPRIGHT,
            SDL_HITTEST_RESIZE_RIGHT,
            SDL_HITTEST_RESIZE_BOTTOMRIGHT,
            SDL_HITTEST_RESIZE_BOTTOM,
            SDL_HITTEST_RESIZE_BOTTOMLEFT,
            SDL_HITTEST_RESIZE_LEFT
        }

        // SDL_audio.h

        define {
            AUDIO_U8 = 0x0008;  /**< Unsigned 8-bit samples */
            AUDIO_S8 = 0x8008;  /**< Signed 8-bit samples */
            AUDIO_U16LSB = 0x0010;  /**< Unsigned 16-bit samples */
            AUDIO_S16LSB = 0x8010;  /**< Signed 16-bit samples */
            AUDIO_U16MSB = 0x1010;  /**< As above, but big-endian byte order */
            AUDIO_S16MSB = 0x9010;  /**< As above, but big-endian byte order */
            AUDIO_U16 = AUDIO_U16LSB;
            AUDIO_S16 = AUDIO_S16LSB;
            AUDIO_S32LSB = 0x8020;  /**< 32-bit integer samples */
            AUDIO_S32MSB = 0x9020;  /**< As above, but big-endian byte order */
            AUDIO_S32 = AUDIO_S32LSB;
            AUDIO_F32LSB = 0x8120;  /**< 32-bit floating point samples */
            AUDIO_F32MSB = 0x9120;  /**< As above, but big-endian byte order */
            AUDIO_F32 = AUDIO_F32LSB;
            // SDL_BYTEORDER == SDL_LIL_ENDIAN
            AUDIO_U16SYS = AUDIO_U16LSB;
            AUDIO_S16SYS = AUDIO_S16LSB;
            AUDIO_S32SYS = AUDIO_S32LSB;
            AUDIO_F32SYS = AUDIO_F32LSB;
        }

        define {
            SDL_MIX_MAXVOLUME = 128;
        }

        // SDL_scancode.h

        enum SDL_Scancode;
        enum {
            SDL_SCANCODE_UNKNOWN = 0,

            /**
            *  \name Usage page 0x07
            *
            *  These values are from usage page 0x07 (USB keyboard page).
            */
            /* @{ */

            SDL_SCANCODE_A = 4,
            SDL_SCANCODE_B = 5,
            SDL_SCANCODE_C = 6,
            SDL_SCANCODE_D = 7,
            SDL_SCANCODE_E = 8,
            SDL_SCANCODE_F = 9,
            SDL_SCANCODE_G = 10,
            SDL_SCANCODE_H = 11,
            SDL_SCANCODE_I = 12,
            SDL_SCANCODE_J = 13,
            SDL_SCANCODE_K = 14,
            SDL_SCANCODE_L = 15,
            SDL_SCANCODE_M = 16,
            SDL_SCANCODE_N = 17,
            SDL_SCANCODE_O = 18,
            SDL_SCANCODE_P = 19,
            SDL_SCANCODE_Q = 20,
            SDL_SCANCODE_R = 21,
            SDL_SCANCODE_S = 22,
            SDL_SCANCODE_T = 23,
            SDL_SCANCODE_U = 24,
            SDL_SCANCODE_V = 25,
            SDL_SCANCODE_W = 26,
            SDL_SCANCODE_X = 27,
            SDL_SCANCODE_Y = 28,
            SDL_SCANCODE_Z = 29,

            SDL_SCANCODE_1 = 30,
            SDL_SCANCODE_2 = 31,
            SDL_SCANCODE_3 = 32,
            SDL_SCANCODE_4 = 33,
            SDL_SCANCODE_5 = 34,
            SDL_SCANCODE_6 = 35,
            SDL_SCANCODE_7 = 36,
            SDL_SCANCODE_8 = 37,
            SDL_SCANCODE_9 = 38,
            SDL_SCANCODE_0 = 39,

            SDL_SCANCODE_RETURN = 40,
            SDL_SCANCODE_ESCAPE = 41,
            SDL_SCANCODE_BACKSPACE = 42,
            SDL_SCANCODE_TAB = 43,
            SDL_SCANCODE_SPACE = 44,

            SDL_SCANCODE_MINUS = 45,
            SDL_SCANCODE_EQUALS = 46,
            SDL_SCANCODE_LEFTBRACKET = 47,
            SDL_SCANCODE_RIGHTBRACKET = 48,
            SDL_SCANCODE_BACKSLASH = 49, /**< Located at the lower left of the return
                                        *   key on ISO keyboards and at the right end
                                        *   of the QWERTY row on ANSI keyboards.
                                        *   Produces REVERSE SOLIDUS (backslash) and
                                        *   VERTICAL LINE in a US layout, REVERSE
                                        *   SOLIDUS and VERTICAL LINE in a UK Mac
                                        *   layout, NUMBER SIGN and TILDE in a UK
                                        *   Windows layout, DOLLAR SIGN and POUND SIGN
                                        *   in a Swiss German layout, NUMBER SIGN and
                                        *   APOSTROPHE in a German layout, GRAVE
                                        *   ACCENT and POUND SIGN in a French Mac
                                        *   layout, and ASTERISK and MICRO SIGN in a
                                        *   French Windows layout.
                                        */
            SDL_SCANCODE_NONUSHASH = 50, /**< ISO USB keyboards actually use this code
                                        *   instead of 49 for the same key, but all
                                        *   OSes I've seen treat the two codes
                                        *   identically. So, as an implementor, unless
                                        *   your keyboard generates both of those
                                        *   codes and your OS treats them differently,
                                        *   you should generate SDL_SCANCODE_BACKSLASH
                                        *   instead of this code. As a user, you
                                        *   should not rely on this code because SDL
                                        *   will never generate it with most (all?)
                                        *   keyboards.
                                        */
            SDL_SCANCODE_SEMICOLON = 51,
            SDL_SCANCODE_APOSTROPHE = 52,
            SDL_SCANCODE_GRAVE = 53, /**< Located in the top left corner (on both ANSI
                                    *   and ISO keyboards). Produces GRAVE ACCENT and
                                    *   TILDE in a US Windows layout and in US and UK
                                    *   Mac layouts on ANSI keyboards, GRAVE ACCENT
                                    *   and NOT SIGN in a UK Windows layout, SECTION
                                    *   SIGN and PLUS-MINUS SIGN in US and UK Mac
                                    *   layouts on ISO keyboards, SECTION SIGN and
                                    *   DEGREE SIGN in a Swiss German layout (Mac:
                                    *   only on ISO keyboards), CIRCUMFLEX ACCENT and
                                    *   DEGREE SIGN in a German layout (Mac: only on
                                    *   ISO keyboards), SUPERSCRIPT TWO and TILDE in a
                                    *   French Windows layout, COMMERCIAL AT and
                                    *   NUMBER SIGN in a French Mac layout on ISO
                                    *   keyboards, and LESS-THAN SIGN and GREATER-THAN
                                    *   SIGN in a Swiss German, German, or French Mac
                                    *   layout on ANSI keyboards.
                                    */
            SDL_SCANCODE_COMMA = 54,
            SDL_SCANCODE_PERIOD = 55,
            SDL_SCANCODE_SLASH = 56,

            SDL_SCANCODE_CAPSLOCK = 57,

            SDL_SCANCODE_F1 = 58,
            SDL_SCANCODE_F2 = 59,
            SDL_SCANCODE_F3 = 60,
            SDL_SCANCODE_F4 = 61,
            SDL_SCANCODE_F5 = 62,
            SDL_SCANCODE_F6 = 63,
            SDL_SCANCODE_F7 = 64,
            SDL_SCANCODE_F8 = 65,
            SDL_SCANCODE_F9 = 66,
            SDL_SCANCODE_F10 = 67,
            SDL_SCANCODE_F11 = 68,
            SDL_SCANCODE_F12 = 69,

            SDL_SCANCODE_PRINTSCREEN = 70,
            SDL_SCANCODE_SCROLLLOCK = 71,
            SDL_SCANCODE_PAUSE = 72,
            SDL_SCANCODE_INSERT = 73, /**< insert on PC, help on some Mac keyboards (but
                                        does send code 73, not 117) */
            SDL_SCANCODE_HOME = 74,
            SDL_SCANCODE_PAGEUP = 75,
            SDL_SCANCODE_DELETE = 76,
            SDL_SCANCODE_END = 77,
            SDL_SCANCODE_PAGEDOWN = 78,
            SDL_SCANCODE_RIGHT = 79,
            SDL_SCANCODE_LEFT = 80,
            SDL_SCANCODE_DOWN = 81,
            SDL_SCANCODE_UP = 82,

            SDL_SCANCODE_NUMLOCKCLEAR = 83, /**< num lock on PC, clear on Mac keyboards
                                            */
            SDL_SCANCODE_KP_DIVIDE = 84,
            SDL_SCANCODE_KP_MULTIPLY = 85,
            SDL_SCANCODE_KP_MINUS = 86,
            SDL_SCANCODE_KP_PLUS = 87,
            SDL_SCANCODE_KP_ENTER = 88,
            SDL_SCANCODE_KP_1 = 89,
            SDL_SCANCODE_KP_2 = 90,
            SDL_SCANCODE_KP_3 = 91,
            SDL_SCANCODE_KP_4 = 92,
            SDL_SCANCODE_KP_5 = 93,
            SDL_SCANCODE_KP_6 = 94,
            SDL_SCANCODE_KP_7 = 95,
            SDL_SCANCODE_KP_8 = 96,
            SDL_SCANCODE_KP_9 = 97,
            SDL_SCANCODE_KP_0 = 98,
            SDL_SCANCODE_KP_PERIOD = 99,

            SDL_SCANCODE_NONUSBACKSLASH = 100, /**< This is the additional key that ISO
                                                *   keyboards have over ANSI ones,
                                                *   located between left shift and Y.
                                                *   Produces GRAVE ACCENT and TILDE in a
                                                *   US or UK Mac layout, REVERSE SOLIDUS
                                                *   (backslash) and VERTICAL LINE in a
                                                *   US or UK Windows layout, and
                                                *   LESS-THAN SIGN and GREATER-THAN SIGN
                                                *   in a Swiss German, German, or French
                                                *   layout. */
            SDL_SCANCODE_APPLICATION = 101, /**< windows contextual menu, compose */
            SDL_SCANCODE_POWER = 102, /**< The USB document says this is a status flag,
                                    *   not a physical key - but some Mac keyboards
                                    *   do have a power key. */
            SDL_SCANCODE_KP_EQUALS = 103,
            SDL_SCANCODE_F13 = 104,
            SDL_SCANCODE_F14 = 105,
            SDL_SCANCODE_F15 = 106,
            SDL_SCANCODE_F16 = 107,
            SDL_SCANCODE_F17 = 108,
            SDL_SCANCODE_F18 = 109,
            SDL_SCANCODE_F19 = 110,
            SDL_SCANCODE_F20 = 111,
            SDL_SCANCODE_F21 = 112,
            SDL_SCANCODE_F22 = 113,
            SDL_SCANCODE_F23 = 114,
            SDL_SCANCODE_F24 = 115,
            SDL_SCANCODE_EXECUTE = 116,
            SDL_SCANCODE_HELP = 117,
            SDL_SCANCODE_MENU = 118,
            SDL_SCANCODE_SELECT = 119,
            SDL_SCANCODE_STOP = 120,
            SDL_SCANCODE_AGAIN = 121,   /**< redo */
            SDL_SCANCODE_UNDO = 122,
            SDL_SCANCODE_CUT = 123,
            SDL_SCANCODE_COPY = 124,
            SDL_SCANCODE_PASTE = 125,
            SDL_SCANCODE_FIND = 126,
            SDL_SCANCODE_MUTE = 127,
            SDL_SCANCODE_VOLUMEUP = 128,
            SDL_SCANCODE_VOLUMEDOWN = 129,
            /* not sure whether there's a reason to enable these */
            /*     SDL_SCANCODE_LOCKINGCAPSLOCK = 130,  */
            /*     SDL_SCANCODE_LOCKINGNUMLOCK = 131, */
            /*     SDL_SCANCODE_LOCKINGSCROLLLOCK = 132, */
            SDL_SCANCODE_KP_COMMA = 133,
            SDL_SCANCODE_KP_EQUALSAS400 = 134,

            SDL_SCANCODE_INTERNATIONAL1 = 135, /**< used on Asian keyboards, see
                                                    footnotes in USB doc */
            SDL_SCANCODE_INTERNATIONAL2 = 136,
            SDL_SCANCODE_INTERNATIONAL3 = 137, /**< Yen */
            SDL_SCANCODE_INTERNATIONAL4 = 138,
            SDL_SCANCODE_INTERNATIONAL5 = 139,
            SDL_SCANCODE_INTERNATIONAL6 = 140,
            SDL_SCANCODE_INTERNATIONAL7 = 141,
            SDL_SCANCODE_INTERNATIONAL8 = 142,
            SDL_SCANCODE_INTERNATIONAL9 = 143,
            SDL_SCANCODE_LANG1 = 144, /**< Hangul/English toggle */
            SDL_SCANCODE_LANG2 = 145, /**< Hanja conversion */
            SDL_SCANCODE_LANG3 = 146, /**< Katakana */
            SDL_SCANCODE_LANG4 = 147, /**< Hiragana */
            SDL_SCANCODE_LANG5 = 148, /**< Zenkaku/Hankaku */
            SDL_SCANCODE_LANG6 = 149, /**< reserved */
            SDL_SCANCODE_LANG7 = 150, /**< reserved */
            SDL_SCANCODE_LANG8 = 151, /**< reserved */
            SDL_SCANCODE_LANG9 = 152, /**< reserved */

            SDL_SCANCODE_ALTERASE = 153, /**< Erase-Eaze */
            SDL_SCANCODE_SYSREQ = 154,
            SDL_SCANCODE_CANCEL = 155,
            SDL_SCANCODE_CLEAR = 156,
            SDL_SCANCODE_PRIOR = 157,
            SDL_SCANCODE_RETURN2 = 158,
            SDL_SCANCODE_SEPARATOR = 159,
            SDL_SCANCODE_OUT = 160,
            SDL_SCANCODE_OPER = 161,
            SDL_SCANCODE_CLEARAGAIN = 162,
            SDL_SCANCODE_CRSEL = 163,
            SDL_SCANCODE_EXSEL = 164,

            SDL_SCANCODE_KP_00 = 176,
            SDL_SCANCODE_KP_000 = 177,
            SDL_SCANCODE_THOUSANDSSEPARATOR = 178,
            SDL_SCANCODE_DECIMALSEPARATOR = 179,
            SDL_SCANCODE_CURRENCYUNIT = 180,
            SDL_SCANCODE_CURRENCYSUBUNIT = 181,
            SDL_SCANCODE_KP_LEFTPAREN = 182,
            SDL_SCANCODE_KP_RIGHTPAREN = 183,
            SDL_SCANCODE_KP_LEFTBRACE = 184,
            SDL_SCANCODE_KP_RIGHTBRACE = 185,
            SDL_SCANCODE_KP_TAB = 186,
            SDL_SCANCODE_KP_BACKSPACE = 187,
            SDL_SCANCODE_KP_A = 188,
            SDL_SCANCODE_KP_B = 189,
            SDL_SCANCODE_KP_C = 190,
            SDL_SCANCODE_KP_D = 191,
            SDL_SCANCODE_KP_E = 192,
            SDL_SCANCODE_KP_F = 193,
            SDL_SCANCODE_KP_XOR = 194,
            SDL_SCANCODE_KP_POWER = 195,
            SDL_SCANCODE_KP_PERCENT = 196,
            SDL_SCANCODE_KP_LESS = 197,
            SDL_SCANCODE_KP_GREATER = 198,
            SDL_SCANCODE_KP_AMPERSAND = 199,
            SDL_SCANCODE_KP_DBLAMPERSAND = 200,
            SDL_SCANCODE_KP_VERTICALBAR = 201,
            SDL_SCANCODE_KP_DBLVERTICALBAR = 202,
            SDL_SCANCODE_KP_COLON = 203,
            SDL_SCANCODE_KP_HASH = 204,
            SDL_SCANCODE_KP_SPACE = 205,
            SDL_SCANCODE_KP_AT = 206,
            SDL_SCANCODE_KP_EXCLAM = 207,
            SDL_SCANCODE_KP_MEMSTORE = 208,
            SDL_SCANCODE_KP_MEMRECALL = 209,
            SDL_SCANCODE_KP_MEMCLEAR = 210,
            SDL_SCANCODE_KP_MEMADD = 211,
            SDL_SCANCODE_KP_MEMSUBTRACT = 212,
            SDL_SCANCODE_KP_MEMMULTIPLY = 213,
            SDL_SCANCODE_KP_MEMDIVIDE = 214,
            SDL_SCANCODE_KP_PLUSMINUS = 215,
            SDL_SCANCODE_KP_CLEAR = 216,
            SDL_SCANCODE_KP_CLEARENTRY = 217,
            SDL_SCANCODE_KP_BINARY = 218,
            SDL_SCANCODE_KP_OCTAL = 219,
            SDL_SCANCODE_KP_DECIMAL = 220,
            SDL_SCANCODE_KP_HEXADECIMAL = 221,

            SDL_SCANCODE_LCTRL = 224,
            SDL_SCANCODE_LSHIFT = 225,
            SDL_SCANCODE_LALT = 226, /**< alt, option */
            SDL_SCANCODE_LGUI = 227, /**< windows, command (apple), meta */
            SDL_SCANCODE_RCTRL = 228,
            SDL_SCANCODE_RSHIFT = 229,
            SDL_SCANCODE_RALT = 230, /**< alt gr, option */
            SDL_SCANCODE_RGUI = 231, /**< windows, command (apple), meta */

            SDL_SCANCODE_MODE = 257,    /**< I'm not sure if this is really not covered
                                        *   by any of the above, but since there's a
                                        *   special KMOD_MODE for it I'm adding it here
                                        */

            /* @} *//* Usage page 0x07 */

            /**
            *  \name Usage page 0x0C
            *
            *  These values are mapped from usage page 0x0C (USB consumer page).
            */
            /* @{ */

            SDL_SCANCODE_AUDIONEXT = 258,
            SDL_SCANCODE_AUDIOPREV = 259,
            SDL_SCANCODE_AUDIOSTOP = 260,
            SDL_SCANCODE_AUDIOPLAY = 261,
            SDL_SCANCODE_AUDIOMUTE = 262,
            SDL_SCANCODE_MEDIASELECT = 263,
            SDL_SCANCODE_WWW = 264,
            SDL_SCANCODE_MAIL = 265,
            SDL_SCANCODE_CALCULATOR = 266,
            SDL_SCANCODE_COMPUTER = 267,
            SDL_SCANCODE_AC_SEARCH = 268,
            SDL_SCANCODE_AC_HOME = 269,
            SDL_SCANCODE_AC_BACK = 270,
            SDL_SCANCODE_AC_FORWARD = 271,
            SDL_SCANCODE_AC_STOP = 272,
            SDL_SCANCODE_AC_REFRESH = 273,
            SDL_SCANCODE_AC_BOOKMARKS = 274,

            /* @} *//* Usage page 0x0C */

            /**
            *  \name Walther keys
            *
            *  These are values that Christian Walther added (for mac keyboard?).
            */
            /* @{ */

            SDL_SCANCODE_BRIGHTNESSDOWN = 275,
            SDL_SCANCODE_BRIGHTNESSUP = 276,
            SDL_SCANCODE_DISPLAYSWITCH = 277, /**< display mirroring/dual display
                                                switch, video mode switch */
            SDL_SCANCODE_KBDILLUMTOGGLE = 278,
            SDL_SCANCODE_KBDILLUMDOWN = 279,
            SDL_SCANCODE_KBDILLUMUP = 280,
            SDL_SCANCODE_EJECT = 281,
            SDL_SCANCODE_SLEEP = 282,

            SDL_SCANCODE_APP1 = 283,
            SDL_SCANCODE_APP2 = 284,

            /* @} *//* Walther keys */

            /**
            *  \name Usage page 0x0C (additional media keys)
            *
            *  These values are mapped from usage page 0x0C (USB consumer page).
            */
            /* @{ */

            SDL_SCANCODE_AUDIOREWIND = 285,
            SDL_SCANCODE_AUDIOFASTFORWARD = 286,

            /* @} *//* Usage page 0x0C (additional media keys) */

            /* Add any other keys here. */

            SDL_NUM_SCANCODES = 512 /**< not a key, just marks the number of scancodes
                                        for array bounds */
        }

        // SDL_keycode.h

        typedef SDL_Keycode int32;

        define {
            SDLK_SCANCODE_MASK = 1 << 30;
        }

        enum {
            SDLK_UNKNOWN = 0,

            SDLK_RETURN = '\r',
            // win32
            SDLK_ESCAPE = 27,
            SDLK_BACKSPACE = '\b',
            SDLK_TAB = '\t',
            SDLK_SPACE = ' ',
            SDLK_EXCLAIM = '!',
            SDLK_QUOTEDBL = '"',
            SDLK_HASH = '#',
            SDLK_PERCENT = '%',
            SDLK_DOLLAR = '$',
            SDLK_AMPERSAND = '&',
            SDLK_QUOTE = '\'',
            SDLK_LEFTPAREN = '(',
            SDLK_RIGHTPAREN = ')',
            SDLK_ASTERISK = '*',
            SDLK_PLUS = '+',
            SDLK_COMMA = ',',
            SDLK_MINUS = '-',
            SDLK_PERIOD = '.',
            SDLK_SLASH = '/',
            SDLK_0 = '0',
            SDLK_1 = '1',
            SDLK_2 = '2',
            SDLK_3 = '3',
            SDLK_4 = '4',
            SDLK_5 = '5',
            SDLK_6 = '6',
            SDLK_7 = '7',
            SDLK_8 = '8',
            SDLK_9 = '9',
            SDLK_COLON = ':',
            SDLK_SEMICOLON = ';',
            SDLK_LESS = '<',
            SDLK_EQUALS = '=',
            SDLK_GREATER = '>',
            SDLK_QUESTION = '?',
            SDLK_AT = '@',
            /*
            Skip uppercase letters
            */
            SDLK_LEFTBRACKET = '[',
            SDLK_BACKSLASH = '\\',
            SDLK_RIGHTBRACKET = ']',
            SDLK_CARET = '^',
            SDLK_UNDERSCORE = '_',
            SDLK_BACKQUOTE = '`',
            SDLK_a = 'a',
            SDLK_b = 'b',
            SDLK_c = 'c',
            SDLK_d = 'd',
            SDLK_e = 'e',
            SDLK_f = 'f',
            SDLK_g = 'g',
            SDLK_h = 'h',
            SDLK_i = 'i',
            SDLK_j = 'j',
            SDLK_k = 'k',
            SDLK_l = 'l',
            SDLK_m = 'm',
            SDLK_n = 'n',
            SDLK_o = 'o',
            SDLK_p = 'p',
            SDLK_q = 'q',
            SDLK_r = 'r',
            SDLK_s = 's',
            SDLK_t = 't',
            SDLK_u = 'u',
            SDLK_v = 'v',
            SDLK_w = 'w',
            SDLK_x = 'x',
            SDLK_y = 'y',
            SDLK_z = 'z',

            SDLK_CAPSLOCK = SDLK_SCANCODE_MASK | SDL_SCANCODE_CAPSLOCK,

            SDLK_F1 = SDLK_SCANCODE_MASK | SDL_SCANCODE_F1,
            SDLK_F2 = SDLK_SCANCODE_MASK | SDL_SCANCODE_F2,
            SDLK_F3 = SDLK_SCANCODE_MASK | SDL_SCANCODE_F3,
            SDLK_F4 = SDLK_SCANCODE_MASK | SDL_SCANCODE_F4,
            SDLK_F5 = SDLK_SCANCODE_MASK | SDL_SCANCODE_F5,
            SDLK_F6 = SDLK_SCANCODE_MASK | SDL_SCANCODE_F6,
            SDLK_F7 = SDLK_SCANCODE_MASK | SDL_SCANCODE_F7,
            SDLK_F8 = SDLK_SCANCODE_MASK | SDL_SCANCODE_F8,
            SDLK_F9 = SDLK_SCANCODE_MASK | SDL_SCANCODE_F9,
            SDLK_F10 = SDLK_SCANCODE_MASK | SDL_SCANCODE_F10,
            SDLK_F11 = SDLK_SCANCODE_MASK | SDL_SCANCODE_F11,
            SDLK_F12 = SDLK_SCANCODE_MASK | SDL_SCANCODE_F12,

            SDLK_PRINTSCREEN = SDLK_SCANCODE_MASK | SDL_SCANCODE_PRINTSCREEN,
            SDLK_SCROLLLOCK = SDLK_SCANCODE_MASK | SDL_SCANCODE_SCROLLLOCK,
            SDLK_PAUSE = SDLK_SCANCODE_MASK | SDL_SCANCODE_PAUSE,
            SDLK_INSERT = SDLK_SCANCODE_MASK | SDL_SCANCODE_INSERT,
            SDLK_HOME = SDLK_SCANCODE_MASK | SDL_SCANCODE_HOME,
            SDLK_PAGEUP = SDLK_SCANCODE_MASK | SDL_SCANCODE_PAGEUP,
            SDLK_DELETE = '\177',
            SDLK_END = SDLK_SCANCODE_MASK | SDL_SCANCODE_END,
            SDLK_PAGEDOWN = SDLK_SCANCODE_MASK | SDL_SCANCODE_PAGEDOWN,
            SDLK_RIGHT = SDLK_SCANCODE_MASK | SDL_SCANCODE_RIGHT,
            SDLK_LEFT = SDLK_SCANCODE_MASK | SDL_SCANCODE_LEFT,
            SDLK_DOWN = SDLK_SCANCODE_MASK | SDL_SCANCODE_DOWN,
            SDLK_UP = SDLK_SCANCODE_MASK | SDL_SCANCODE_UP,

            SDLK_NUMLOCKCLEAR = SDLK_SCANCODE_MASK | SDL_SCANCODE_NUMLOCKCLEAR,
            SDLK_KP_DIVIDE = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_DIVIDE,
            SDLK_KP_MULTIPLY = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_MULTIPLY,
            SDLK_KP_MINUS = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_MINUS,
            SDLK_KP_PLUS = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_PLUS,
            SDLK_KP_ENTER = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_ENTER,
            SDLK_KP_1 = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_1,
            SDLK_KP_2 = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_2,
            SDLK_KP_3 = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_3,
            SDLK_KP_4 = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_4,
            SDLK_KP_5 = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_5,
            SDLK_KP_6 = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_6,
            SDLK_KP_7 = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_7,
            SDLK_KP_8 = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_8,
            SDLK_KP_9 = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_9,
            SDLK_KP_0 = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_0,
            SDLK_KP_PERIOD = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_PERIOD,

            SDLK_APPLICATION = SDLK_SCANCODE_MASK | SDL_SCANCODE_APPLICATION,
            SDLK_POWER = SDLK_SCANCODE_MASK | SDL_SCANCODE_POWER,
            SDLK_KP_EQUALS = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_EQUALS,
            SDLK_F13 = SDLK_SCANCODE_MASK | SDL_SCANCODE_F13,
            SDLK_F14 = SDLK_SCANCODE_MASK | SDL_SCANCODE_F14,
            SDLK_F15 = SDLK_SCANCODE_MASK | SDL_SCANCODE_F15,
            SDLK_F16 = SDLK_SCANCODE_MASK | SDL_SCANCODE_F16,
            SDLK_F17 = SDLK_SCANCODE_MASK | SDL_SCANCODE_F17,
            SDLK_F18 = SDLK_SCANCODE_MASK | SDL_SCANCODE_F18,
            SDLK_F19 = SDLK_SCANCODE_MASK | SDL_SCANCODE_F19,
            SDLK_F20 = SDLK_SCANCODE_MASK | SDL_SCANCODE_F20,
            SDLK_F21 = SDLK_SCANCODE_MASK | SDL_SCANCODE_F21,
            SDLK_F22 = SDLK_SCANCODE_MASK | SDL_SCANCODE_F22,
            SDLK_F23 = SDLK_SCANCODE_MASK | SDL_SCANCODE_F23,
            SDLK_F24 = SDLK_SCANCODE_MASK | SDL_SCANCODE_F24,
            SDLK_EXECUTE = SDLK_SCANCODE_MASK | SDL_SCANCODE_EXECUTE,
            SDLK_HELP = SDLK_SCANCODE_MASK | SDL_SCANCODE_HELP,
            SDLK_MENU = SDLK_SCANCODE_MASK | SDL_SCANCODE_MENU,
            SDLK_SELECT = SDLK_SCANCODE_MASK | SDL_SCANCODE_SELECT,
            SDLK_STOP = SDLK_SCANCODE_MASK | SDL_SCANCODE_STOP,
            SDLK_AGAIN = SDLK_SCANCODE_MASK | SDL_SCANCODE_AGAIN,
            SDLK_UNDO = SDLK_SCANCODE_MASK | SDL_SCANCODE_UNDO,
            SDLK_CUT = SDLK_SCANCODE_MASK | SDL_SCANCODE_CUT,
            SDLK_COPY = SDLK_SCANCODE_MASK | SDL_SCANCODE_COPY,
            SDLK_PASTE = SDLK_SCANCODE_MASK | SDL_SCANCODE_PASTE,
            SDLK_FIND = SDLK_SCANCODE_MASK | SDL_SCANCODE_FIND,
            SDLK_MUTE = SDLK_SCANCODE_MASK | SDL_SCANCODE_MUTE,
            SDLK_VOLUMEUP = SDLK_SCANCODE_MASK | SDL_SCANCODE_VOLUMEUP,
            SDLK_VOLUMEDOWN = SDLK_SCANCODE_MASK | SDL_SCANCODE_VOLUMEDOWN,
            SDLK_KP_COMMA = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_COMMA,
            SDLK_KP_EQUALSAS400 =
                SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_EQUALSAS400,

            SDLK_ALTERASE = SDLK_SCANCODE_MASK | SDL_SCANCODE_ALTERASE,
            SDLK_SYSREQ = SDLK_SCANCODE_MASK | SDL_SCANCODE_SYSREQ,
            SDLK_CANCEL = SDLK_SCANCODE_MASK | SDL_SCANCODE_CANCEL,
            SDLK_CLEAR = SDLK_SCANCODE_MASK | SDL_SCANCODE_CLEAR,
            SDLK_PRIOR = SDLK_SCANCODE_MASK | SDL_SCANCODE_PRIOR,
            SDLK_RETURN2 = SDLK_SCANCODE_MASK | SDL_SCANCODE_RETURN2,
            SDLK_SEPARATOR = SDLK_SCANCODE_MASK | SDL_SCANCODE_SEPARATOR,
            SDLK_OUT = SDLK_SCANCODE_MASK | SDL_SCANCODE_OUT,
            SDLK_OPER = SDLK_SCANCODE_MASK | SDL_SCANCODE_OPER,
            SDLK_CLEARAGAIN = SDLK_SCANCODE_MASK | SDL_SCANCODE_CLEARAGAIN,
            SDLK_CRSEL = SDLK_SCANCODE_MASK | SDL_SCANCODE_CRSEL,
            SDLK_EXSEL = SDLK_SCANCODE_MASK | SDL_SCANCODE_EXSEL,

            SDLK_KP_00 = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_00,
            SDLK_KP_000 = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_000,
            SDLK_THOUSANDSSEPARATOR =
                SDLK_SCANCODE_MASK | SDL_SCANCODE_THOUSANDSSEPARATOR,
            SDLK_DECIMALSEPARATOR =
                SDLK_SCANCODE_MASK | SDL_SCANCODE_DECIMALSEPARATOR,
            SDLK_CURRENCYUNIT = SDLK_SCANCODE_MASK | SDL_SCANCODE_CURRENCYUNIT,
            SDLK_CURRENCYSUBUNIT =
                SDLK_SCANCODE_MASK | SDL_SCANCODE_CURRENCYSUBUNIT,
            SDLK_KP_LEFTPAREN = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_LEFTPAREN,
            SDLK_KP_RIGHTPAREN = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_RIGHTPAREN,
            SDLK_KP_LEFTBRACE = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_LEFTBRACE,
            SDLK_KP_RIGHTBRACE = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_RIGHTBRACE,
            SDLK_KP_TAB = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_TAB,
            SDLK_KP_BACKSPACE = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_BACKSPACE,
            SDLK_KP_A = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_A,
            SDLK_KP_B = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_B,
            SDLK_KP_C = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_C,
            SDLK_KP_D = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_D,
            SDLK_KP_E = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_E,
            SDLK_KP_F = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_F,
            SDLK_KP_XOR = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_XOR,
            SDLK_KP_POWER = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_POWER,
            SDLK_KP_PERCENT = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_PERCENT,
            SDLK_KP_LESS = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_LESS,
            SDLK_KP_GREATER = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_GREATER,
            SDLK_KP_AMPERSAND = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_AMPERSAND,
            SDLK_KP_DBLAMPERSAND =
                SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_DBLAMPERSAND,
            SDLK_KP_VERTICALBAR =
                SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_VERTICALBAR,
            SDLK_KP_DBLVERTICALBAR =
                SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_DBLVERTICALBAR,
            SDLK_KP_COLON = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_COLON,
            SDLK_KP_HASH = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_HASH,
            SDLK_KP_SPACE = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_SPACE,
            SDLK_KP_AT = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_AT,
            SDLK_KP_EXCLAM = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_EXCLAM,
            SDLK_KP_MEMSTORE = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_MEMSTORE,
            SDLK_KP_MEMRECALL = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_MEMRECALL,
            SDLK_KP_MEMCLEAR = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_MEMCLEAR,
            SDLK_KP_MEMADD = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_MEMADD,
            SDLK_KP_MEMSUBTRACT =
                SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_MEMSUBTRACT,
            SDLK_KP_MEMMULTIPLY =
                SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_MEMMULTIPLY,
            SDLK_KP_MEMDIVIDE = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_MEMDIVIDE,
            SDLK_KP_PLUSMINUS = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_PLUSMINUS,
            SDLK_KP_CLEAR = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_CLEAR,
            SDLK_KP_CLEARENTRY = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_CLEARENTRY,
            SDLK_KP_BINARY = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_BINARY,
            SDLK_KP_OCTAL = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_OCTAL,
            SDLK_KP_DECIMAL = SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_DECIMAL,
            SDLK_KP_HEXADECIMAL =
                SDLK_SCANCODE_MASK | SDL_SCANCODE_KP_HEXADECIMAL,

            SDLK_LCTRL = SDLK_SCANCODE_MASK | SDL_SCANCODE_LCTRL,
            SDLK_LSHIFT = SDLK_SCANCODE_MASK | SDL_SCANCODE_LSHIFT,
            SDLK_LALT = SDLK_SCANCODE_MASK | SDL_SCANCODE_LALT,
            SDLK_LGUI = SDLK_SCANCODE_MASK | SDL_SCANCODE_LGUI,
            SDLK_RCTRL = SDLK_SCANCODE_MASK | SDL_SCANCODE_RCTRL,
            SDLK_RSHIFT = SDLK_SCANCODE_MASK | SDL_SCANCODE_RSHIFT,
            SDLK_RALT = SDLK_SCANCODE_MASK | SDL_SCANCODE_RALT,
            SDLK_RGUI = SDLK_SCANCODE_MASK | SDL_SCANCODE_RGUI,

            SDLK_MODE = SDLK_SCANCODE_MASK | SDL_SCANCODE_MODE,

            SDLK_AUDIONEXT = SDLK_SCANCODE_MASK | SDL_SCANCODE_AUDIONEXT,
            SDLK_AUDIOPREV = SDLK_SCANCODE_MASK | SDL_SCANCODE_AUDIOPREV,
            SDLK_AUDIOSTOP = SDLK_SCANCODE_MASK | SDL_SCANCODE_AUDIOSTOP,
            SDLK_AUDIOPLAY = SDLK_SCANCODE_MASK | SDL_SCANCODE_AUDIOPLAY,
            SDLK_AUDIOMUTE = SDLK_SCANCODE_MASK | SDL_SCANCODE_AUDIOMUTE,
            SDLK_MEDIASELECT = SDLK_SCANCODE_MASK | SDL_SCANCODE_MEDIASELECT,
            SDLK_WWW = SDLK_SCANCODE_MASK | SDL_SCANCODE_WWW,
            SDLK_MAIL = SDLK_SCANCODE_MASK | SDL_SCANCODE_MAIL,
            SDLK_CALCULATOR = SDLK_SCANCODE_MASK | SDL_SCANCODE_CALCULATOR,
            SDLK_COMPUTER = SDLK_SCANCODE_MASK | SDL_SCANCODE_COMPUTER,
            SDLK_AC_SEARCH = SDLK_SCANCODE_MASK | SDL_SCANCODE_AC_SEARCH,
            SDLK_AC_HOME = SDLK_SCANCODE_MASK | SDL_SCANCODE_AC_HOME,
            SDLK_AC_BACK = SDLK_SCANCODE_MASK | SDL_SCANCODE_AC_BACK,
            SDLK_AC_FORWARD = SDLK_SCANCODE_MASK | SDL_SCANCODE_AC_FORWARD,
            SDLK_AC_STOP = SDLK_SCANCODE_MASK | SDL_SCANCODE_AC_STOP,
            SDLK_AC_REFRESH = SDLK_SCANCODE_MASK | SDL_SCANCODE_AC_REFRESH,
            SDLK_AC_BOOKMARKS = SDLK_SCANCODE_MASK | SDL_SCANCODE_AC_BOOKMARKS,

            SDLK_BRIGHTNESSDOWN =
                SDLK_SCANCODE_MASK | SDL_SCANCODE_BRIGHTNESSDOWN,
            SDLK_BRIGHTNESSUP = SDLK_SCANCODE_MASK | SDL_SCANCODE_BRIGHTNESSUP,
            SDLK_DISPLAYSWITCH = SDLK_SCANCODE_MASK | SDL_SCANCODE_DISPLAYSWITCH,
            SDLK_KBDILLUMTOGGLE =
                SDLK_SCANCODE_MASK | SDL_SCANCODE_KBDILLUMTOGGLE,
            SDLK_KBDILLUMDOWN = SDLK_SCANCODE_MASK | SDL_SCANCODE_KBDILLUMDOWN,
            SDLK_KBDILLUMUP = SDLK_SCANCODE_MASK | SDL_SCANCODE_KBDILLUMUP,
            SDLK_EJECT = SDLK_SCANCODE_MASK | SDL_SCANCODE_EJECT,
            SDLK_SLEEP = SDLK_SCANCODE_MASK | SDL_SCANCODE_SLEEP,
            SDLK_APP1 = SDLK_SCANCODE_MASK | SDL_SCANCODE_APP1,
            SDLK_APP2 = SDLK_SCANCODE_MASK | SDL_SCANCODE_APP2,

            SDLK_AUDIOREWIND = SDLK_SCANCODE_MASK | SDL_SCANCODE_AUDIOREWIND,
            SDLK_AUDIOFASTFORWARD = SDLK_SCANCODE_MASK | SDL_SCANCODE_AUDIOFASTFORWARD
        }

        enum SDL_Keymod;
        enum {
            KMOD_NONE = 0x0000,
            KMOD_LSHIFT = 0x0001,
            KMOD_RSHIFT = 0x0002,
            KMOD_LCTRL = 0x0040,
            KMOD_RCTRL = 0x0080,
            KMOD_LALT = 0x0100,
            KMOD_RALT = 0x0200,
            KMOD_LGUI = 0x0400,
            KMOD_RGUI = 0x0800,
            KMOD_NUM = 0x1000,
            KMOD_CAPS = 0x2000,
            KMOD_MODE = 0x4000,
            KMOD_RESERVED = 0x8000
        }

        define {
            KMOD_CTRL = (KMOD_LCTRL|KMOD_RCTRL);
            KMOD_SHIFT = (KMOD_LSHIFT|KMOD_RSHIFT);
            KMOD_ALT = (KMOD_LALT|KMOD_RALT);
            KMOD_GUI = (KMOD_LGUI|KMOD_RGUI);
        }

        // SDL_keyboard.h

        struct SDL_Keysym {
            scancode SDL_Scancode;      /**< SDL physical key code - see ::SDL_Scancode for details */
            sym SDL_Keycode;            /**< SDL virtual key code - see ::SDL_Keycode for details */
            mod uint16;                 /**< current key modifiers */
            unused uint32;
        }

        // SDL_mouse.h

        enum SDL_SystemCursor;
        enum {
            SDL_SYSTEM_CURSOR_ARROW,     /**< Arrow */
            SDL_SYSTEM_CURSOR_IBEAM,     /**< I-beam */
            SDL_SYSTEM_CURSOR_WAIT,      /**< Wait */
            SDL_SYSTEM_CURSOR_CROSSHAIR, /**< Crosshair */
            SDL_SYSTEM_CURSOR_WAITARROW, /**< Small wait cursor (or Wait if not available) */
            SDL_SYSTEM_CURSOR_SIZENWSE,  /**< Double arrow pointing northwest and southeast */
            SDL_SYSTEM_CURSOR_SIZENESW,  /**< Double arrow pointing northeast and southwest */
            SDL_SYSTEM_CURSOR_SIZEWE,    /**< Double arrow pointing west and east */
            SDL_SYSTEM_CURSOR_SIZENS,    /**< Double arrow pointing north and south */
            SDL_SYSTEM_CURSOR_SIZEALL,   /**< Four pointed arrow pointing north, south, east, and west */
            SDL_SYSTEM_CURSOR_NO,        /**< Slashed circle or crossbones */
            SDL_SYSTEM_CURSOR_HAND,      /**< Hand */
            SDL_NUM_SYSTEM_CURSORS
        }

        enum SDL_MouseWheelDirection;
        enum {
            SDL_MOUSEWHEEL_NORMAL,    /**< The scroll direction is normal */
            SDL_MOUSEWHEEL_FLIPPED    /**< The scroll direction is flipped / natural */
        }

        inline SDL_BUTTON(X uint) uint {
            return 1 << (X - 1);
        }

        define {
            SDL_BUTTON_LEFT = 1;
            SDL_BUTTON_MIDDLE = 2;
            SDL_BUTTON_RIGHT = 3;
            SDL_BUTTON_X1 = 4;
            SDL_BUTTON_X2 = 5;
            SDL_BUTTON_LMASK = 1 << (SDL_BUTTON_LEFT - 1);
            SDL_BUTTON_MMASK = 1 << (SDL_BUTTON_MIDDLE - 1);
            SDL_BUTTON_RMASK = 1 << (SDL_BUTTON_RIGHT - 1);
            SDL_BUTTON_X1MASK = 1 << (SDL_BUTTON_X1 - 1);
            SDL_BUTTON_X2MASK = 1 << (SDL_BUTTON_X2 - 1);
        }

        // SDL_joystick.h

        typedef SDL_JoystickID int32;

        // SDL_touch.h

        typedef SDL_TouchID int64;
        typedef SDL_FingerID int64;

        // SDL_gesture.h

        typedef SDL_GestureID int64;

        // SDL_events.h

        define {
            SDL_RELEASED = 0;
            SDL_PRESSED = 1;
        }

        enum SDL_EventType;
        enum {
            SDL_FIRSTEVENT     = 0,     /**< Unused (do not remove) */

            /* Application events */
            SDL_QUIT           = 0x100, /**< User-requested quit */

            /* These application events have special meaning on iOS, see README-ios.md for details */
            SDL_APP_TERMINATING,        /**< The application is being terminated by the OS
                                            Called on iOS in applicationWillTerminate()
                                            Called on Android in onDestroy()
                                        */
            SDL_APP_LOWMEMORY,          /**< The application is low on memory, free memory if possible.
                                            Called on iOS in applicationDidReceiveMemoryWarning()
                                            Called on Android in onLowMemory()
                                        */
            SDL_APP_WILLENTERBACKGROUND, /**< The application is about to enter the background
                                            Called on iOS in applicationWillResignActive()
                                            Called on Android in onPause()
                                        */
            SDL_APP_DIDENTERBACKGROUND, /**< The application did enter the background and may not get CPU for some time
                                            Called on iOS in applicationDidEnterBackground()
                                            Called on Android in onPause()
                                        */
            SDL_APP_WILLENTERFOREGROUND, /**< The application is about to enter the foreground
                                            Called on iOS in applicationWillEnterForeground()
                                            Called on Android in onResume()
                                        */
            SDL_APP_DIDENTERFOREGROUND, /**< The application is now interactive
                                            Called on iOS in applicationDidBecomeActive()
                                            Called on Android in onResume()
                                        */

            /* Display events */
            SDL_DISPLAYEVENT   = 0x150,  /**< Display state change */

            /* Window events */
            SDL_WINDOWEVENT    = 0x200, /**< Window state change */
            SDL_SYSWMEVENT,             /**< System specific event */

            /* Keyboard events */
            SDL_KEYDOWN        = 0x300, /**< Key pressed */
            SDL_KEYUP,                  /**< Key released */
            SDL_TEXTEDITING,            /**< Keyboard text editing (composition) */
            SDL_TEXTINPUT,              /**< Keyboard text input */
            SDL_KEYMAPCHANGED,          /**< Keymap changed due to a system event such as an
                                            input language or keyboard layout change.
                                        */

            /* Mouse events */
            SDL_MOUSEMOTION    = 0x400, /**< Mouse moved */
            SDL_MOUSEBUTTONDOWN,        /**< Mouse button pressed */
            SDL_MOUSEBUTTONUP,          /**< Mouse button released */
            SDL_MOUSEWHEEL,             /**< Mouse wheel motion */

            /* Joystick events */
            SDL_JOYAXISMOTION  = 0x600, /**< Joystick axis motion */
            SDL_JOYBALLMOTION,          /**< Joystick trackball motion */
            SDL_JOYHATMOTION,           /**< Joystick hat position change */
            SDL_JOYBUTTONDOWN,          /**< Joystick button pressed */
            SDL_JOYBUTTONUP,            /**< Joystick button released */
            SDL_JOYDEVICEADDED,         /**< A new joystick has been inserted into the system */
            SDL_JOYDEVICEREMOVED,       /**< An opened joystick has been removed */

            /* Game controller events */
            SDL_CONTROLLERAXISMOTION  = 0x650, /**< Game controller axis motion */
            SDL_CONTROLLERBUTTONDOWN,          /**< Game controller button pressed */
            SDL_CONTROLLERBUTTONUP,            /**< Game controller button released */
            SDL_CONTROLLERDEVICEADDED,         /**< A new Game controller has been inserted into the system */
            SDL_CONTROLLERDEVICEREMOVED,       /**< An opened Game controller has been removed */
            SDL_CONTROLLERDEVICEREMAPPED,      /**< The controller mapping was updated */

            /* Touch events */
            SDL_FINGERDOWN      = 0x700,
            SDL_FINGERUP,
            SDL_FINGERMOTION,

            /* Gesture events */
            SDL_DOLLARGESTURE   = 0x800,
            SDL_DOLLARRECORD,
            SDL_MULTIGESTURE,

            /* Clipboard events */
            SDL_CLIPBOARDUPDATE = 0x900, /**< The clipboard changed */

            /* Drag and drop events */
            SDL_DROPFILE        = 0x1000, /**< The system requests a file open */
            SDL_DROPTEXT,                 /**< text/plain drag-and-drop event */
            SDL_DROPBEGIN,                /**< A new set of drops is beginning (NULL filename) */
            SDL_DROPCOMPLETE,             /**< Current set of drops is now complete (NULL filename) */

            /* Audio hotplug events */
            SDL_AUDIODEVICEADDED = 0x1100, /**< A new audio device is available */
            SDL_AUDIODEVICEREMOVED,        /**< An audio device has been removed. */

            /* Sensor events */
            SDL_SENSORUPDATE = 0x1200,     /**< A sensor was updated */

            /* Render events */
            SDL_RENDER_TARGETS_RESET = 0x2000, /**< The render targets have been reset and their contents need to be updated */
            SDL_RENDER_DEVICE_RESET, /**< The device has been reset and all textures need to be recreated */

            /** Events ::SDL_USEREVENT through ::SDL_LASTEVENT are for your use,
            *  and should be allocated with SDL_RegisterEvents()
            */
            SDL_USEREVENT    = 0x8000,

            /**
            *  This last event is only for bounding internal arrays
            */
            SDL_LASTEVENT    = 0xFFFF
        }

        struct SDL_CommonEvent {
            type uint32;
            timestamp uint32;   /**< In milliseconds, populated using SDL_GetTicks() */
        }

        struct SDL_DisplayEvent {
            type uint32;        /**< ::SDL_DISPLAYEVENT */
            timestamp uint32;   /**< In milliseconds, populated using SDL_GetTicks() */
            display uint32;     /**< The associated display index */
            event uint8;        /**< ::SDL_DisplayEventID */
            padding1 uint8;
            padding2 uint8;
            padding3 uint8;
            data1 int32;       /**< event dependent data */
        }

        struct SDL_WindowEvent {
            type uint32;        /**< ::SDL_WINDOWEVENT */
            timestamp uint32;   /**< In milliseconds, populated using SDL_GetTicks() */
            windowID uint32;    /**< The associated window */
            event uint8;        /**< ::SDL_WindowEventID */
            padding1 uint8;
            padding2 uint8;
            padding3 uint8;
            data1 int32;       /**< event dependent data */
            data2 int32;       /**< event dependent data */
        }

        struct SDL_KeyboardEvent {
            type uint32;        /**< ::SDL_KEYDOWN or ::SDL_KEYUP */
            timestamp uint32;   /**< In milliseconds, populated using SDL_GetTicks() */
            windowID uint32;    /**< The window with keyboard focus, if any */
            state uint8;        /**< ::SDL_PRESSED or ::SDL_RELEASED */
            repeat uint8;       /**< Non-zero if this is a key repeat */
            padding2 uint8;
            padding3 uint8;
            keysym SDL_Keysym;  /**< The key that was pressed or released */
        }

        define {
            SDL_TEXTEDITINGEVENT_TEXT_SIZE = (32);
        }

        struct SDL_TextEditingEvent {
            type uint32;                                /**< ::SDL_TEXTEDITING */
            timestamp uint32;                           /**< In milliseconds, populated using SDL_GetTicks() */
            windowID uint32;                            /**< The window with keyboard focus, if any */
            text(SDL_TEXTEDITINGEVENT_TEXT_SIZE) char;  /**< The editing text */
            start int32;                               /**< The start cursor of selected editing text */
            length int32;                              /**< The length of selected editing text */
        }

        define {
            SDL_TEXTINPUTEVENT_TEXT_SIZE = (32);
        }

        struct SDL_TextInputEvent {
            type uint32;                              /**< ::SDL_TEXTINPUT */
            timestamp uint32;                         /**< In milliseconds, populated using SDL_GetTicks() */
            windowID uint32;                          /**< The window with keyboard focus, if any */
            text(SDL_TEXTINPUTEVENT_TEXT_SIZE) char;  /**< The input text */
        }

        struct SDL_MouseMotionEvent {
            type uint32;        /**< ::SDL_MOUSEMOTION */
            timestamp uint32;   /**< In milliseconds, populated using SDL_GetTicks() */
            windowID uint32;    /**< The window with mouse focus, if any */
            which uint32;       /**< The mouse instance id, or SDL_TOUCH_MOUSEID */
            state uint32;       /**< The current button state */
            x int32;           /**< X coordinate, relative to window */
            y int32;           /**< Y coordinate, relative to window */
            xrel int32;        /**< The relative motion in the X direction */
            yrel int32;        /**< The relative motion in the Y direction */
        }

        struct SDL_MouseButtonEvent {
            type uint32;        /**< ::SDL_MOUSEBUTTONDOWN or ::SDL_MOUSEBUTTONUP */
            timestamp uint32;   /**< In milliseconds, populated using SDL_GetTicks() */
            windowID uint32;    /**< The window with mouse focus, if any */
            which uint32;       /**< The mouse instance id, or SDL_TOUCH_MOUSEID */
            button uint8;       /**< The mouse button index */
            state uint8;        /**< ::SDL_PRESSED or ::SDL_RELEASED */
            clicks uint8;       /**< 1 for single-click, 2 for double-click, etc. */
            padding1 uint8;
            x int32;           /**< X coordinate, relative to window */
            y int32;           /**< Y coordinate, relative to window */
        }

        struct SDL_MouseWheelEvent {
            type uint32;        /**< ::SDL_MOUSEWHEEL */
            timestamp uint32;   /**< In milliseconds, populated using SDL_GetTicks() */
            windowID uint32;    /**< The window with mouse focus, if any */
            which uint32;       /**< The mouse instance id, or SDL_TOUCH_MOUSEID */
            x int32;           /**< The amount scrolled horizontally, positive to the right and negative to the left */
            y int32;           /**< The amount scrolled vertically, positive away from the user and negative toward the user */
            direction uint32;   /**< Set to one of the SDL_MOUSEWHEEL_* defines. When FLIPPED the values in X and Y will be opposite. Multiply by -1 to change them back */
        }

        struct SDL_JoyAxisEvent {
            type uint32;        /**< ::SDL_JOYAXISMOTION */
            timestamp uint32;   /**< In milliseconds, populated using SDL_GetTicks() */
            which SDL_JoystickID; /**< The joystick instance id */
            axis uint8;         /**< The joystick axis index */
            padding1 uint8;
            padding2 uint8;
            padding3 uint8;
            value int16;       /**< The axis value (range: -32768 to 32767) */
            padding4 uint16;
        }

        struct SDL_JoyBallEvent {
            type uint32;        /**< ::SDL_JOYBALLMOTION */
            timestamp uint32;   /**< In milliseconds, populated using SDL_GetTicks() */
            which SDL_JoystickID; /**< The joystick instance id */
            ball uint8;         /**< The joystick trackball index */
            padding1 uint8;
            padding2 uint8;
            padding3 uint8;
            xrel int16;        /**< The relative motion in the X direction */
            yrel int16;        /**< The relative motion in the Y direction */
        }

        struct SDL_JoyHatEvent {
            type uint32;        /**< ::SDL_JOYHATMOTION */
            timestamp uint32;   /**< In milliseconds, populated using SDL_GetTicks() */
            which SDL_JoystickID; /**< The joystick instance id */
            hat uint8;          /**< The joystick hat index */
            value uint8;        /**< The hat position value.
                                *   \sa ::SDL_HAT_LEFTUP ::SDL_HAT_UP ::SDL_HAT_RIGHTUP
                                *   \sa ::SDL_HAT_LEFT ::SDL_HAT_CENTERED ::SDL_HAT_RIGHT
                                *   \sa ::SDL_HAT_LEFTDOWN ::SDL_HAT_DOWN ::SDL_HAT_RIGHTDOWN
                                *
                                *   Note that zero means the POV is centered.
                                */
            padding1 uint8;
            padding2 uint8;
        }

        struct SDL_JoyButtonEvent {
            type uint32;        /**< ::SDL_JOYBUTTONDOWN or ::SDL_JOYBUTTONUP */
            timestamp uint32;   /**< In milliseconds, populated using SDL_GetTicks() */
            which SDL_JoystickID; /**< The joystick instance id */
            button uint8;       /**< The joystick button index */
            state uint8;        /**< ::SDL_PRESSED or ::SDL_RELEASED */
            padding1 uint8;
            padding2 uint8;
        }

        struct SDL_JoyDeviceEvent {
            type uint32;        /**< ::SDL_JOYDEVICEADDED or ::SDL_JOYDEVICEREMOVED */
            timestamp uint32;   /**< In milliseconds, populated using SDL_GetTicks() */
            which int32;       /**< The joystick device index for the ADDED event, instance id for the REMOVED event */
        }

        struct SDL_ControllerAxisEvent {
            type uint32;        /**< ::SDL_CONTROLLERAXISMOTION */
            timestamp uint32;   /**< In milliseconds, populated using SDL_GetTicks() */
            which SDL_JoystickID; /**< The joystick instance id */
            axis uint8;         /**< The controller axis (SDL_GameControllerAxis) */
            padding1 uint8;
            padding2 uint8;
            padding3 uint8;
            value int16;       /**< The axis value (range: -32768 to 32767) */
            padding4 uint16;
        }

        struct SDL_ControllerButtonEvent {
            type uint32;        /**< ::SDL_CONTROLLERBUTTONDOWN or ::SDL_CONTROLLERBUTTONUP */
            timestamp uint32;   /**< In milliseconds, populated using SDL_GetTicks() */
            which SDL_JoystickID; /**< The joystick instance id */
            button uint8;       /**< The controller button (SDL_GameControllerButton) */
            state uint8;        /**< ::SDL_PRESSED or ::SDL_RELEASED */
            padding1 uint8;
            padding2 uint8;
        }

        struct SDL_ControllerDeviceEvent {
            type uint32;        /**< ::SDL_CONTROLLERDEVICEADDED, ::SDL_CONTROLLERDEVICEREMOVED, or ::SDL_CONTROLLERDEVICEREMAPPED */
            timestamp uint32;   /**< In milliseconds, populated using SDL_GetTicks() */
            which int32;       /**< The joystick device index for the ADDED event, instance id for the REMOVED or REMAPPED event */
        }

        struct SDL_AudioDeviceEvent {
            type uint32;        /**< ::SDL_AUDIODEVICEADDED, or ::SDL_AUDIODEVICEREMOVED */
            timestamp uint32;   /**< In milliseconds, populated using SDL_GetTicks() */
            which uint32;       /**< The audio device index for the ADDED event (valid until next SDL_GetNumAudioDevices() call), SDL_AudioDeviceID for the REMOVED event */
            iscapture uint8;    /**< zero if an output device, non-zero if a capture device. */
            padding1 uint8;
            padding2 uint8;
            padding3 uint8;
        }

        struct SDL_TouchFingerEvent {
            type uint32;        /**< ::SDL_FINGERMOTION or ::SDL_FINGERDOWN or ::SDL_FINGERUP */
            timestamp uint32;   /**< In milliseconds, populated using SDL_GetTicks() */
            touchId SDL_TouchID; /**< The touch device id */
            fingerId SDL_FingerID;
            x float;            /**< Normalized in the range 0...1 */
            y float;            /**< Normalized in the range 0...1 */
            dx float;           /**< Normalized in the range -1...1 */
            dy float;           /**< Normalized in the range -1...1 */
            pressure float;     /**< Normalized in the range 0...1 */
        }

        struct SDL_MultiGestureEvent {
            type uint32;        /**< ::SDL_MULTIGESTURE */
            timestamp uint32;   /**< In milliseconds, populated using SDL_GetTicks() */
            touchId SDL_TouchID; /**< The touch device id */
            dTheta float;
            dDist float;
            x float;
            y float;
            numFingers uint16;
            padding uint16;
        }

        struct SDL_DollarGestureEvent {
            type uint32;        /**< ::SDL_DOLLARGESTURE or ::SDL_DOLLARRECORD */
            timestamp uint32;   /**< In milliseconds, populated using SDL_GetTicks() */
            touchId SDL_TouchID; /**< The touch device id */
            gestureId SDL_GestureID;
            numFingers uint32;
            error float;
            x float;            /**< Normalized center of gesture */
            y float;            /**< Normalized center of gesture */
        }

        struct SDL_DropEvent {
            type uint32;        /**< ::SDL_DROPBEGIN or ::SDL_DROPFILE or ::SDL_DROPTEXT or ::SDL_DROPCOMPLETE */
            timestamp uint32;   /**< In milliseconds, populated using SDL_GetTicks() */
            file. char;         /**< The file name, which should be freed with SDL_free(), is NULL on begin/complete */
            windowID uint32;    /**< The window that was dropped on, if any */
        }

        struct SDL_SensorEvent {
            type uint32;        /**< ::SDL_SENSORUPDATE */
            timestamp uint32;   /**< In milliseconds, populated using SDL_GetTicks() */
            which int32;       /**< The instance ID of the sensor */
            data(6) float;      /**< Up to 6 values from the sensor - additional values can be queried using SDL_SensorGetData() */
        }

        struct SDL_QuitEvent {
            type uint32;        /**< ::SDL_QUIT */
            timestamp uint32;   /**< In milliseconds, populated using SDL_GetTicks() */
        }

        struct SDL_OSEvent {
            type uint32;        /**< ::SDL_QUIT */
            timestamp uint32;   /**< In milliseconds, populated using SDL_GetTicks() */
        }

        struct SDL_UserEvent {
            type uint32;        /**< ::SDL_USEREVENT through ::SDL_LASTEVENT-1 */
            timestamp uint32;   /**< In milliseconds, populated using SDL_GetTicks() */
            windowID uint32;    /**< The associated window if any */
            code int32;        /**< User defined event code */
            data1 void;        /**< User defined data pointer */
            data2 void;        /**< User defined data pointer */
        }

        struct SDL_SysWMEvent {
            type uint32;        /**< ::SDL_SYSWMEVENT */
            timestamp uint32;   /**< In milliseconds, populated using SDL_GetTicks() */
            msg+ SDL_SysWMmsg;  /**< driver dependent data, defined in SDL_syswm.h */
        }

        union SDL_Event {
            type uint32;                    /**< Event type, shared with all events */
            common SDL_CommonEvent;         /**< Common event data */
            display SDL_DisplayEvent;       /**< Window event data */
            window SDL_WindowEvent;         /**< Window event data */
            key SDL_KeyboardEvent;          /**< Keyboard event data */
            edit SDL_TextEditingEvent;      /**< Text editing event data */
            text SDL_TextInputEvent;        /**< Text input event data */
            motion SDL_MouseMotionEvent;    /**< Mouse motion event data */
            button SDL_MouseButtonEvent;    /**< Mouse button event data */
            wheel SDL_MouseWheelEvent;      /**< Mouse wheel event data */
            jaxis SDL_JoyAxisEvent;         /**< Joystick axis event data */
            jball SDL_JoyBallEvent;         /**< Joystick ball event data */
            jhat SDL_JoyHatEvent;           /**< Joystick hat event data */
            jbutton SDL_JoyButtonEvent;     /**< Joystick button event data */
            jdevice SDL_JoyDeviceEvent;     /**< Joystick device change event data */
            caxis SDL_ControllerAxisEvent;      /**< Game Controller axis event data */
            cbutton SDL_ControllerButtonEvent;  /**< Game Controller button event data */
            cdevice SDL_ControllerDeviceEvent;  /**< Game Controller device event data */
            adevice SDL_AudioDeviceEvent;   /**< Audio device event data */
            sensor SDL_SensorEvent;         /**< Sensor event data */
            quit SDL_QuitEvent;             /**< Quit request event data */
            user SDL_UserEvent;             /**< Custom event data */
            syswm SDL_SysWMEvent;           /**< System dependent window event data */
            tfinger SDL_TouchFingerEvent;   /**< Touch finger event data */
            mgesture SDL_MultiGestureEvent; /**< Gesture event data */
            dgesture SDL_DollarGestureEvent; /**< Gesture event data */
            drop SDL_DropEvent;             /**< Drag and drop event data */

            /* This is necessary for ABI compatibility between Visual C++ and GCC
            Visual C++ will respect the push pack pragma and use 52 bytes for
            this structure, and GCC will use the alignment of the largest datatype
            within the union, which is 8 bytes.

            So... we'll add padding to force the size to be 56 bytes for both.
            */
            padding(56) uint8;
        }

        enum SDL_eventaction;
        enum {
            SDL_ADDEVENT,
            SDL_PEEKEVENT,
            SDL_GETEVENT
        }

        define {
            SDL_QUERY = -1;
            SDL_IGNORE = 0;
            SDL_DISABLE = 0;
            SDL_ENABLE = 1;
        }

        // SDL_render.h

        enum SDL_RendererFlags;
        enum {
            SDL_RENDERER_SOFTWARE = 0x00000001,         /**< The renderer is a software fallback */
            SDL_RENDERER_ACCELERATED = 0x00000002,      /**< The renderer uses hardware acceleration */
            SDL_RENDERER_PRESENTVSYNC = 0x00000004,     /**< Present is synchronized with the refresh rate */
            SDL_RENDERER_TARGETTEXTURE = 0x00000008     /**< The renderer supports rendering to texture */
        }

        struct SDL_RendererInfo {
            name. char;           /**< The name of the renderer */
            flags uint32;               /**< Supported ::SDL_RendererFlags */
            num_texture_formats uint32; /**< The number of available texture formats */
            texture_formats(16) uint32; /**< The available texture formats */
            max_texture_width int;      /**< The maximum texture width */
            max_texture_height int;     /**< The maximum texture height */
        }

        enum SDL_TextureAccess;
        enum {
            SDL_TEXTUREACCESS_STATIC,    /**< Changes rarely, not lockable */
            SDL_TEXTUREACCESS_STREAMING, /**< Changes frequently, lockable */
            SDL_TEXTUREACCESS_TARGET     /**< Texture can be used as a render target */
        }

        enum SDL_TextureModulate;
        enum {
            SDL_TEXTUREMODULATE_NONE = 0x00000000,     /**< No modulation */
            SDL_TEXTUREMODULATE_COLOR = 0x00000001,    /**< srcC = srcC * color */
            SDL_TEXTUREMODULATE_ALPHA = 0x00000002     /**< srcA = srcA * alpha */
        }

        enum SDL_RendererFlip;
        enum {
            SDL_FLIP_NONE = 0x00000000,     /**< Do not flip */
            SDL_FLIP_HORIZONTAL = 0x00000001,    /**< flip horizontally */
            SDL_FLIP_VERTICAL = 0x00000002     /**< flip vertically */
        }

        // SDL_pixels.h

        define {
            SDL_ALPHA_OPAQUE = 255;
            SDL_ALPHA_TRANSPARENT = 0;
        }

        // SDL_BYTEORDER == SDL_LIL_ENDIAN
        enum {
            SDL_PIXELFORMAT_UNKNOWN,
            SDL_PIXELFORMAT_INDEX1LSB = 286261504,
            SDL_PIXELFORMAT_INDEX1MSB = 287310080,
            SDL_PIXELFORMAT_INDEX4LSB = 303039488,
            SDL_PIXELFORMAT_INDEX4MSB = 304088064,
            SDL_PIXELFORMAT_INDEX8 = 318769153,
            SDL_PIXELFORMAT_RGB332 = 336660481,
            SDL_PIXELFORMAT_RGB444 = 353504258,
            SDL_PIXELFORMAT_RGB555 = 353570562,
            SDL_PIXELFORMAT_BGR555 = 357764866,
            SDL_PIXELFORMAT_ARGB4444 = 355602434,
            SDL_PIXELFORMAT_RGBA4444 = 356651010,
            SDL_PIXELFORMAT_ABGR4444 = 359796738,
            SDL_PIXELFORMAT_BGRA4444 = 360845314,
            SDL_PIXELFORMAT_ARGB1555 = 355667970,
            SDL_PIXELFORMAT_RGBA5551 = 356782082,
            SDL_PIXELFORMAT_ABGR1555 = 359862274,
            SDL_PIXELFORMAT_BGRA5551 = 360976386,
            SDL_PIXELFORMAT_RGB565 = 353701890,
            SDL_PIXELFORMAT_BGR565 = 357896194,
            SDL_PIXELFORMAT_RGB24 = 386930691,
            SDL_PIXELFORMAT_BGR24 = 390076419,
            SDL_PIXELFORMAT_RGB888 = 370546692,
            SDL_PIXELFORMAT_RGBX8888 = 371595268,
            SDL_PIXELFORMAT_BGR888 = 374740996,
            SDL_PIXELFORMAT_BGRX8888 = 375789572,
            SDL_PIXELFORMAT_ARGB8888 = 372645892,
            SDL_PIXELFORMAT_RGBA8888 = 373694468,
            SDL_PIXELFORMAT_ABGR8888 = 376840196,
            SDL_PIXELFORMAT_BGRA8888 = 377888772,
            SDL_PIXELFORMAT_ARGB2101010 = 372711428,

            /* Aliases for RGBA byte arrays of color data, for the current platform */

            SDL_PIXELFORMAT_RGBA32 = SDL_PIXELFORMAT_ABGR8888,
            SDL_PIXELFORMAT_ARGB32 = SDL_PIXELFORMAT_BGRA8888,
            SDL_PIXELFORMAT_BGRA32 = SDL_PIXELFORMAT_ARGB8888,
            SDL_PIXELFORMAT_ABGR32 = SDL_PIXELFORMAT_RGBA8888,

            SDL_PIXELFORMAT_YV12 = 842094168,
            SDL_PIXELFORMAT_IYUV = 1448433993,
            SDL_PIXELFORMAT_YUY2 = 844715353,
            SDL_PIXELFORMAT_UYVY = 1498831189,
            SDL_PIXELFORMAT_YVYU = 1431918169,
            SDL_PIXELFORMAT_NV12 = 842094158,
            SDL_PIXELFORMAT_NV21 = 825382478,
            SDL_PIXELFORMAT_EXTERNAL_OES = 542328143
        }

        struct SDL_Color {
            r uint8;
            g uint8;
            b uint8;
            a uint8;
        }

        typedef SDL_Colour SDL_Color;

        struct SDL_Palette {
            ncolors int;
            colors. SDL_Color;
            version uint32;
            refcount int;
        }

        struct SDL_PixelFormat {
            format uint32;
            palette. SDL_Palette;
            BitsPerPixel uint8;
            BytesPerPixel uint8;
            padding(2) uint8;
            Rmask uint32;
            Gmask uint32;
            Bmask uint32;
            Amask uint32;
            Rloss uint8;
            Gloss uint8;
            Bloss uint8;
            Aloss uint8;
            Rshift uint8;
            Gshift uint8;
            Bshift uint8;
            Ashift uint8;
            refcount int;
            next. SDL_PixelFormat;
        }

        // SDL_surface.h

        define {
            SDL_SWSURFACE = 0;           /**< Just here for compatibility */
            SDL_PREALLOC = 0x00000001;  /**< Surface uses preallocated memory */
            SDL_RLEACCEL = 0x00000002;  /**< Surface is RLE encoded */
            SDL_DONTFREE = 0x00000004;  /**< Surface is referenced internally */
        }

        inline SDL_MUSTLOCK(S. SDL_Surface) int {
            return (S.flags & SDL_RLEACCEL) ~= 0;
        }

        struct SDL_Surface {
            flags uint32;               /**< Read-only */
            format+ SDL_PixelFormat;    /**< Read-only */
            w int, h int;                   /**< Read-only */
            pitch int;                  /**< Read-only */
            pixels void;               /**< Read-write */
            /** Application data associated with the surface */
            userdata void;             /**< Read-write */
            /** information needed for surfaces requiring locks */
            locked int;                 /**< Read-only */
            lock_data void;            /**< Read-only */
            /** clipping information */
            clip_rect SDL_Rect;         /**< Read-only */
            /** info for fast blit mapping to other surfaces */
            map+ SDL_BlitMap;    /**< Private */
            /** Reference count -- used when freeing surface */
            refcount int;               /**< Read-mostly */
        }

        enum SDL_YUV_CONVERSION_MODE;
        enum {
            SDL_YUV_CONVERSION_JPEG,        /**< Full range JPEG */
            SDL_YUV_CONVERSION_BT601,       /**< BT.601 (the default) */
            SDL_YUV_CONVERSION_BT709,       /**< BT.709 */
            SDL_YUV_CONVERSION_AUTOMATIC    /**< BT.601 for SD content, BT.709 for HD content */
        }

    }

    module sdl2+ {

        // SDL.h

        inline SDL_Init(flags uint32) int {
            return call1<int>(so::fn.SDL_Init, flags);
        }

        inline SDL_Quit() {
            call<void>(so::fn.SDL_Quit);
        }

        // SDL_error.h

            // SDL_SetError(fmt. char, ...) int

        inline SDL_GetError() .char {
            return call<char*>(so::fn.SDL_GetError);
        }

        inline SDL_ClearError() {
            call<void>(so::fn.SDL_ClearError);
        }

        inline SDL_Error(code SDL_errorcode) int {
            return call1<int>(so::fn.SDL_Error, code);
        }

        // SDL_hints.h

        inline SDL_SetHint(name. char, value. char) SDL_bool {
            return call2<SDL_bool>(so::fn.SDL_SetHint, name, value);
        }

        inline SDL_GetHint(name. char) .char {
            return call1<char*>(name);
        }

        // SDL_rect.h

        inline SDL_PointInRect(p. SDL_Point, r. SDL_Rect) SDL_bool {
            if (p.x >= r.x) and (p.x < (r.x + r.w)) and (p.y >= r.y) and (p.y < (r.y + r.h));
                return SDL_TRUE;
            return SDL_FALSE;
        }

        inline SDL_RectEmpty(r. SDL_Rect) SDL_bool {
            if r == null or (r.w <= 0) or (r.h <= 0);
                return SDL_TRUE;
            return SDL_FALSE;
        }

        inline SDL_RectEquals(a. SDL_Rect, b. SDL_Rect) SDL_bool {
            if a ~= null and b ~= null and (a.x == b.x) and (a.y == b.y) and (a.w == b.w) and (a.h == b.h);
                return SDL_TRUE;
            return SDL_FALSE;
        }

        inline SDL_HasIntersection(A. SDL_Rect, B. SDL_Rect) SDL_bool {
            return call2<SDL_bool>(so::fn.SDL_HasIntersection, A, B);
        }

        inline SDL_IntersectRect(A. SDL_Rect, B. SDL_Rect, result. SDL_Rect) SDL_bool {
            return call3<SDL_bool>(so::fn.SDL_IntersectRect, A, B, result);
        }

        inline SDL_UnionRect(A. SDL_Rect, B. SDL_Rect, result. SDL_Rect) {
            call3<void>(so::fn.SDL_UnionRect, A, B, result);
        }

        inline SDL_EnclosePoints(points. SDL_Point, count int, clip. SDL_Rect, result. SDL_Rect) SDL_bool {
            return call4<SDL_bool>(so::fn.SDL_EnclosePoints, points, count, clip, result);
        }

        inline SDL_IntersectRectAndLine(rect. SDL_Rect, X1. int, Y1. int, X2. int, Y2. int) SDL_bool {
            return call5<SDL_bool>(so::fn.SDL_IntersectRectAndLine, rect, X1, Y1, X2, Y2);
        }

        // SDL_timer.h

        inline SDL_GetTicks() uint32 {
            return call<uint32>(so::fn.SDL_GetTicks);
        }

        inline SDL_GetPerformanceCounter() uint64 {
            return call_64<uint64>(so::fn.SDL_GetPerformanceCounter);
        }

        inline SDL_GetPerformanceFrequency() uint64 {
            return call_64<uint64>(so::fn.SDL_GetPerformanceFrequency);
        }

        inline SDL_Delay(ms uint32) {
            call1<void>(so::fn.SDL_Delay, ms);
        }

        func SDL_TimerCallback(interval uint32, param void) uint32;

        inline SDL_AddTimer(interval uint32, callback+ SDL_TimerCallback, param void) SDL_TimerID {
            return call3<SDL_TimerID>(so::fn.SDL_AddTimer, interval, callback, param);
        }

        inline SDL_RemoveTimer(id SDL_TimerID) SDL_bool {
            return call1<SDL_bool>(so::fn.SDL_RemoveTimer, id);
        }

        // SDL_rwops.h

        inline SDL_RWFromFile(file. char, mode. char) .SDL_RWops {
            return call2<void>(so::fn.SDL_RWFromFile, file, mode);
        }

        inline SDL_RWFromFP(fp+ FILE, autoclose SDL_bool) .SDL_RWops {
            return call2<void>(so::fn.SDL_RWFromFP, fp, autoclose);
        }

        inline SDL_RWFromMem(mem void, size int) .SDL_RWops {
            return call2<void>(so::fn.SDL_RWFromMem, mem, size);
        }

        inline SDL_RWFromConstMem(mem void, size int) .SDL_RWops {
            return call2<void>(so::fn.SDL_RWFromConstMem, mem, size);
        }

        inline SDL_AllocRW() .SDL_RWops {
            return call<void>(so::fn.SDL_AllocRW);
        }

        inline SDL_FreeRW(area. SDL_RWops) {
            call1<void>(so::fn.SDL_FreeRW, area);
        }

        inline SDL_RWsize(ctx. SDL_RWops) int64 {
            return call_64_1<int64>(ctx.size, ctx);
        }

        inline SDL_RWseek(ctx. SDL_RWops, offset int64, whence int) int64 {
            return call_64_3<int64>(ctx.seek, ctx, offset, whence);
        }

        inline SDL_RWtell(ctx. SDL_RWops) int64 {
            return call_64_3<int64>(ctx.seek, ctx, 0, RW_SEEK_CUR);
        }

        inline SDL_RWread(ctx. SDL_RWops, ptr void, size size_t, n size_t) size_t {
            return call4<size_t>(ctx.read, ctx, ptr, size, n);
        }

        inline SDL_RWwrite(ctx. SDL_RWops, ptr void, size size_t, n size_t) size_t {
            return call4<size_t>(ctx.write, ctx, ptr, size, n);
        }

        inline SDL_RWclose(ctx. SDL_RWops) int {
            return call1<int>(ctx.close, ctx);
        }

        // SDL_video.h

        inline SDL_GL_GetProcAddress(proc. char) void {
            return call1<void>(so::fn.SDL_GL_GetProcAddress, proc);
        }

        inline SDL_GetNumVideoDrivers() int {
            return call<int>(so::fn.SDL_GetNumVideoDrivers);
        }

        inline SDL_GetVideoDriver(index int) .char {
            return call1<char*>(so::fn.SDL_GetVideoDriver, index);
        }
        
        inline SDL_VideoInit(driver_name. char) int {
            return call1<int>(so::fn.SDL_VideoInit, driver_name);
        }
        
        inline SDL_VideoQuit() {
            call<void>(so::fn.SDL_VideoQuit);
        }
        
        inline SDL_GetCurrentVideoDriver() .char {
            return call<char*>(so::fn.SDL_GetCurrentVideoDriver);
        }
        
        inline SDL_GetNumVideoDisplays() int {
            return call<int>(so::fn.SDL_GetNumVideoDisplays);
        }
        
        inline SDL_GetDisplayName(displayIndex int) .char {
            return call1<char*>(so::fn.SDL_GetDisplayName, displayIndex);
        }
        
        inline SDL_GetDisplayBounds(displayIndex int, rect. SDL_Rect) int {
            return call2<int>(so::fn.SDL_GetDisplayBounds, displayIndex, rect);
        }
        
        inline SDL_GetDisplayUsableBounds(displayIndex int, rect. SDL_Rect) int {
            return call2<int>(so::fn.SDL_GetDisplayUsableBounds, displayIndex, rect);
        }
        
        inline SDL_GetDisplayDPI(displayIndex int, ddpi. float, hdpi. float, vdpi. float) int {
            return call4<int>(so::fn.SDL_GetDisplayDPI, displayIndex, ddpi, hdpi, vdpi);
        }
        
        inline SDL_GetNumDisplayModes(displayIndex int) int {
            return call1<int>(so::fn.SDL_GetNumDisplayModes, displayIndex);
        }
        
        inline SDL_GetDisplayMode(displayIndex int, modeIndex int, mode. SDL_DisplayMode) int {
            return call3<int>(so::fn.SDL_GetDisplayMode, displayIndex, modeIndex, mode);
        }
        
        inline SDL_GetDesktopDisplayMode(displayIndex int, mode. SDL_DisplayMode) int {
            return call2<int>(so::fn.SDL_GetDesktopDisplayMode, displayIndex, mode);
        }
        
        inline SDL_GetCurrentDisplayMode(displayIndex int, mode. SDL_DisplayMode) int {
            return call2<int>(so::fn.SDL_GetCurrentDisplayMode, displayIndex, mode);
        }
        
        inline SDL_GetClosestDisplayMode(displayIndex int, mode. SDL_DisplayMode, closest. SDL_DisplayMode) .SDL_DisplayMode {
            return call3<void>(so::fn.SDL_GetClosestDisplayMode, displayIndex, mode, closest);
        }
        
        inline SDL_GetWindowDisplayIndex(window+ SDL_Window) int {
            return call1<int>(so::fn.SDL_GetWindowDisplayIndex, window);
        }
        
        inline SDL_SetWindowDisplayMode(window+ SDL_Window, mode. SDL_DisplayMode) int {
            return call2<int>(so::fn.SDL_SetWindowDisplayMode, window, mode);
        }
        
        inline SDL_GetWindowDisplayMode(window+ SDL_Window, mode. SDL_DisplayMode) int {
            return call2<int>(so::fn.SDL_GetWindowDisplayMode, window, mode);
        }
        
        inline SDL_GetWindowPixelFormat(window+ SDL_Window) uint32 {
            return call1<uint32>(so::fn.SDL_GetWindowPixelFormat, window);
        }

        inline SDL_CreateWindow(title. char, x int, y int, w int, h int, flags uint32) +SDL_Window {
            return call6<void>(so::fn.SDL_CreateWindow, title, x, y, w, h, flags);
        }

        inline SDL_CreateWindowFrom(data void) +SDL_Window {
            return call1<void>(so::fn.SDL_CreateWindowFrom, data);
        }

        inline SDL_DestroyWindow(window+ SDL_Window) {
            call1<void>(so::fn.SDL_DestroyWindow, window);
        }

        inline SDL_GetWindowID(window+ SDL_Window) uint32 {
            return call1<uint32>(so::fn.SDL_GetWindowID, window);
        }

        inline SDL_GetWindowFromID(id uint32) +SDL_Window {
            return call1<void>(so::fn.SDL_GetWindowFromID, id);
        }

        inline SDL_GetWindowFlags(window+ SDL_Window) uint32 {
            return call1<uint32>(so::fn.SDL_GetWindowFlags, window);
        }

        inline SDL_SetWindowTitle(window+ SDL_Window, title. char) {
            call2<void>(so::fn.SDL_SetWindowTitle, window, title);
        }

        inline SDL_GetWindowTitle(window+ SDL_Window) .char {
            return call1<char*>(so::fn.SDL_GetWindowTitle, window);
        }

        inline SDL_SetWindowIcon(window+ SDL_Window, icon. SDL_Surface) {
            call2<void>(so::fn.SDL_SetWindowIcon, window, icon);
        }

        inline SDL_SetWindowData(window+ SDL_Window, name. char, userdata void) void {
            return call3<void>(so::fn.SDL_SetWindowData, window, name, userdata);
        }

        inline SDL_GetWindowData(window+ SDL_Window, name. char) void {
            return call2<void>(so::fn.SDL_GetWindowData, window, name);
        }

        inline SDL_SetWindowPosition(window+ SDL_Window, x int, y int) {
            call3<void>(so::fn.SDL_SetWindowPosition, window, x, y);
        }

        inline SDL_GetWindowPosition(window+ SDL_Window, x. int, y. int) {
            call3<void>(so::fn.SDL_GetWindowPosition, window, x, y);
        }

        inline SDL_SetWindowSize(window+ SDL_Window, w int, h int) {
            call3<void>(so::fn.SDL_SetWindowSize, window, w, h);
        }

        inline SDL_GetWindowSize(window+ SDL_Window, w. int, h. int) {
            call3<void>(so::fn.SDL_GetWindowSize, window, w, h);
        }

        inline SDL_GetWindowBordersSize(window+ SDL_Window, top. int, left. int, bottom. int, right. int) int {
            return call5<int>(so::fn.SDL_GetWindowBordersSize, window, top, left, bottom, right);
        }

        inline SDL_SetWindowMinimumSize(window+ SDL_Window, min_w int, min_h int) {
            call3<void>(so::fn.SDL_SetWindowMinimumSize, window, min_w, min_h);
        }

        inline SDL_GetWindowMinimumSize(window+ SDL_Window, w. int, h. int) {
            call3<void>(so::fn.SDL_GetWindowMinimumSize, window, w, h);
        }

        inline SDL_SetWindowMaximumSize(window+ SDL_Window, max_w int, max_h int) {
            call3<void>(so::fn.SDL_SetWindowMaximumSize, window, max_w, max_h);
        }

        inline SDL_GetWindowMaximumSize(window+ SDL_Window, w. int, h. int) {
            call3<void>(so::fn.SDL_GetWindowMaximumSize, window, w, h);
        }

        inline SDL_SetWindowBordered(window+ SDL_Window, bordered SDL_bool) {
            call2<void>(so::fn.SDL_SetWindowBordered, window, bordered);
        }

        inline SDL_SetWindowResizable(window+ SDL_Window, resizable SDL_bool) {
            call2<void>(so::fn.SDL_SetWindowResizable, window, resizable);
        }

        inline SDL_ShowWindow(window+ SDL_Window) {
            call1<void>(so::fn.SDL_ShowWindow, window);
        }

        inline SDL_HideWindow(window+ SDL_Window) {
            call1<void>(so::fn.SDL_HideWindow, window);
        }

        inline SDL_RaiseWindow(window+ SDL_Window) {
            call1<void>(so::fn.SDL_RaiseWindow, window);
        }

        inline SDL_MaximizeWindow(window+ SDL_Window) {
            call1<void>(so::fn.SDL_MaximizeWindow, window);
        }

        inline SDL_MinimizeWindow(window+ SDL_Window) {
            call1<void>(so::fn.SDL_MinimizeWindow, window);
        }

        inline SDL_RestoreWindow(window+ SDL_Window) {
            call1<void>(so::fn.SDL_RestoreWindow, window);
        }

        inline SDL_SetWindowFullscreen(window+ SDL_Window, flags uint32) int {
            return call2<int>(so::fn.SDL_SetWindowFullscreen, window, flags);
        }

        inline SDL_GetWindowSurface(window+ SDL_Window) .SDL_Surface {
            return call1<void>(so::fn.SDL_GetWindowSurface, window);
        }

        inline SDL_UpdateWindowSurface(window+ SDL_Window) int {
            return call1<int>(so::fn.SDL_UpdateWindowSurface, window);
        }

        inline SDL_UpdateWindowSurfaceRects(window+ SDL_Window, rects. SDL_Rect, numrects int) int {
            return call3<int>(so::fn.SDL_UpdateWindowSurfaceRects, window, rects, numrects);
        }

        inline SDL_SetWindowGrab(window+ SDL_Window, grabbed SDL_bool) {
            call2<void>(so::fn.SDL_SetWindowGrab, window, grabbed);
        }

        inline SDL_GetWindowGrab(window+ SDL_Window) SDL_bool {
            return call1<SDL_bool>(so::fn.SDL_GetWindowGrab, window);
        }

        inline SDL_GetGrabbedWindow() +SDL_Window {
            return call<void>(so::fn.SDL_GetGrabbedWindow);
        }

        inline SDL_SetWindowBrightness(window+ SDL_Window, brightness float) int {
            return call_rf<int>(so::fn.SDL_SetWindowBrightness, window, brightness);
        }

        inline SDL_GetWindowBrightness(window+ SDL_Window) float {
            return callf_r<float>(so::fn.SDL_GetWindowBrightness, window);
        }

        inline SDL_SetWindowOpacity(window+ SDL_Window, opacity float) int {
            return call_rf<int>(so::fn.SDL_SetWindowOpacity, window, opacity);
        }

        inline SDL_GetWindowOpacity(window+ SDL_Window, out_opacity. float) int {
            return call2<int>(so::fn.SDL_GetWindowOpacity, window, out_opacity);
        }

        inline SDL_SetWindowModalFor(modal_window+ SDL_Window, parent_window+ SDL_Window) int {
            return call2<int>(so::fn.SDL_SetWindowModalFor, modal_window, parent_window);
        }

        inline SDL_SetWindowInputFocus(window+ SDL_Window) int {
            return call1<int>(so::fn.SDL_SetWindowInputFocus, window);
        }

        inline SDL_SetWindowGammaRamp(window+ SDL_Window, red. uint16, green. uint16, blue. uint16) int {
            return call4<int>(so::fn.SDL_SetWindowGammaRamp, window, red, green, blue);
        }

        inline SDL_GetWindowGammaRamp(window+ SDL_Window, red. uint16, green. uint16, blue. uint16) int {
            return call4<int>(so::fn.SDL_GetWindowGammaRamp, window, red, green, blue);
        }

        func SDL_HitTest(win+ SDL_Window, area. SDL_Point, data void) SDL_HitTestResult;

        inline SDL_SetWindowHitTest(window+ SDL_Window, callback+ SDL_HitTest, callback_data void) int {
            return call3<int>(so::fn.SDL_SetWindowHitTest, window, callback, callback_data);
        }

        inline SDL_IsScreenSaverEnabled() SDL_bool {
            return call<SDL_bool>(so::fn.SDL_IsScreenSaverEnabled);
        }

        inline SDL_EnableScreenSaver() {
            call<void>(so::fn.SDL_EnableScreenSaver);
        }

        inline SDL_DisableScreenSaver() {
            call<void>(so::fn.SDL_DisableScreenSaver);
        }
        
        // SDL_keyboard.h

        inline SDL_GetKeyboardFocus() +SDL_Window {
            return call<void>(so::fn.SDL_GetKeyboardFocus);
        }

        inline SDL_GetKeyboardState(numkeys. int) .uint8 {
            return call1<uint8*>(so::fn.SDL_GetKeyboardState, numkeys);
        }

        inline SDL_GetModState() SDL_Keymod {
            return call<SDL_Keymod>(so::fn.SDL_GetModState);
        }

        inline SDL_SetModState(modstate SDL_Keymod) {
            call1<void>(so::fn.SDL_SetModState, modstate);
        }

        inline SDL_GetKeyFromScancode(scancode SDL_Scancode) SDL_Keycode {
            return call1<SDL_Keycode>(so::fn.SDL_GetKeyFromScancode, scancode);
        }

        inline SDL_GetScancodeFromKey(key SDL_Keycode) SDL_Scancode {
            return call1<SDL_Scancode>(so::fn.SDL_GetScancodeFromKey, key);
        }

        inline SDL_GetScancodeName(scancode SDL_Scancode) .char {
            return call1<char*>(so::fn.SDL_GetScancodeName, scancode);
        }

        inline SDL_GetScancodeFromName(name. char) SDL_Scancode {
            return call1<SDL_Scancode>(so::fn.SDL_GetScancodeFromName, name);
        }

        inline SDL_GetKeyName(key SDL_Keycode) .char {
            return call1<char*>(so::fn.SDL_GetKeyName, key);
        }

        inline SDL_GetKeyFromName(name. char) SDL_Keycode {
            return call1<SDL_Keycode>(so::fn.SDL_GetKeyFromName, name);
        }

        inline SDL_StartTextInput() {
            call<void>(so::fn.SDL_StartTextInput);
        }

        inline SDL_IsTextInputActive() SDL_bool {
            return call<SDL_bool>(so::fn.SDL_IsTextInputActive);
        }

        inline SDL_StopTextInput() {
            call<void>(so::fn.SDL_StopTextInput);
        }

        inline SDL_SetTextInputRect(rect. SDL_Rect) {
            call1<void>(so::fn.SDL_SetTextInputRect, rect);
        }

        inline SDL_HasScreenKeyboardSupport() SDL_bool {
            return call<SDL_bool>(so::fn.SDL_HasScreenKeyboardSupport);
        }

        inline SDL_IsScreenKeyboardShown(window+ SDL_Window) SDL_bool {
            return call1<SDL_bool>(so::fn.SDL_IsScreenKeyboardShown, window);
        }

        // SDL_mouse.h

        inline SDL_GetMouseFocus() +SDL_Window {
            return call<void>(so::fn.SDL_GetMouseFocus);
        }

        inline SDL_GetMouseState(x. int, y. int) uint32 {
            return call2<uint32>(so::fn.SDL_GetMouseState, x, y);
        }

        inline SDL_GetGlobalMouseState(x. int, y. int) uint32 {
            return call2<uint32>(so::fn.SDL_GetGlobalMouseState, x, y);
        }

        inline SDL_GetRelativeMouseState(x. int, y. int) uint32 {
            return call2<uint32>(so::fn.SDL_GetRelativeMouseState, x, y);
        }

        inline SDL_WarpMouseInWindow(window+ SDL_Window, x int, y int) {
            call3<void>(so::fn.SDL_WarpMouseInWindow, window, x, y);
        }

        inline SDL_WarpMouseGlobal(x int, y int) int {
            return call2<int>(so::fn.SDL_WarpMouseGlobal, x, y);
        }

        inline SDL_SetRelativeMouseMode(enabled SDL_bool) int {
            return call1<int>(so::fn.SDL_SetRelativeMouseMode, enabled);
        }

        inline SDL_CaptureMouse(enabled SDL_bool) int {
            return call1<int>(so::fn.SDL_CaptureMouse, enabled);
        }

        inline SDL_GetRelativeMouseMode() SDL_bool {
            return call<SDL_bool>(so::fn.SDL_GetRelativeMouseMode);
        }

        inline SDL_CreateCursor(data. uint8, mask. uint8, w int, h int, hot_x int, hot_y int) +SDL_Cursor {
            return call6<void>(so::fn.SDL_CreateCursor, data, mask, w, h, hot_x, hot_y);
        }

        inline SDL_CreateColorCursor(surface. SDL_Surface, hot_x int, hot_y int) +SDL_Cursor {
            return call3<void>(so::fn.SDL_CreateColorCursor, surface, hot_x, hot_y);
        }

        inline SDL_CreateSystemCursor(id SDL_SystemCursor) +SDL_Cursor {
            return call1<void>(so::fn.SDL_CreateSystemCursor, id);
        }

        inline SDL_SetCursor(cursor+ SDL_Cursor) {
            call1<void>(so::fn.SDL_SetCursor, cursor);
        }

        inline SDL_GetCursor() +SDL_Cursor {
            return call<void>(so::fn.SDL_GetCursor);
        }

        inline SDL_GetDefaultCursor() +SDL_Cursor {
            return call<void>(so::fn.SDL_GetDefaultCursor);
        }

        inline SDL_FreeCursor(cursor+ SDL_Cursor) {
            call1<void>(so::fn.SDL_FreeCursor, cursor);
        }

        inline SDL_ShowCursor(toggle int) int {
            return call1<int>(so::fn.SDL_ShowCursor, toggle);
        }

        // SDL_events.h

        inline SDL_PumpEvents() {
            call<void>(so::fn.SDL_PumpEvents);
        }

        inline SDL_PeepEvents(events. SDL_Event, numevents int, action SDL_eventaction, minType uint32, maxType uint32) int {
            return call5<int>(so::fn.SDL_PeepEvents, events, numevents, action, minType, maxType);
        }

        inline SDL_HasEvent(type uint32) SDL_bool {
            return call1<SDL_bool>(so::fn.SDL_HasEvent, type);
        }

        inline SDL_HasEvents(minType uint32, maxType uint32) SDL_bool {
            return call2<SDL_bool>(so::fn.SDL_HasEvents, minType, maxType);
        }

        inline SDL_FlushEvent(type uint32) {
            call1<void>(so::fn.SDL_FlushEvent, type);
        }

        inline SDL_FlushEvents(minType uint32, maxType uint32) {
            call2<void>(so::fn.SDL_FlushEvents, minType, maxType);
        }

        inline SDL_PollEvent(event. SDL_Event) int {
            return call1<int>(so::fn.SDL_PollEvent, event);
        }

        inline SDL_WaitEvent(event. SDL_Event) int {
            return call1<int>(so::fn.SDL_WaitEvent, event);
        }

        inline SDL_WaitEventTimeout(event. SDL_Event, timeout int) int {
            return call2<int>(so::fn.SDL_WaitEventTimeout, event, timeout);
        }

        inline SDL_PushEvent(event. SDL_Event) int {
            return call1<int>(so::fn.SDL_PushEvent, event);
        }

        func SDL_EventFilter(userdata void, event. SDL_Event) int;

        inline SDL_SetEventFilter(filter+ SDL_EventFilter, userdata void) {
            call2<void>(so::fn.SDL_SetEventFilter, filter, userdata);
        }

        inline SDL_GetEventFilter(filter++ SDL_EventFilter, userdata+ void) SDL_bool {
            return call2<SDL_bool>(so::fn.SDL_GetEventFilter, filter, userdata);
        }

        inline SDL_AddEventWatch(filter+ SDL_EventFilter, userdata void) {
            call2<void>(so::fn.SDL_AddEventWatch, filter, userdata);
        }

        inline SDL_DelEventWatch(filter+ SDL_EventFilter, userdata void) {
            call2<void>(so::fn.SDL_DelEventWatch, filter, userdata);
        }

        inline SDL_FilterEvents(filter+ SDL_EventFilter, userdata void) {
            call2<void>(so::fn.SDL_FilterEvents, filter, userdata);
        }

        inline SDL_EventState(type uint32, state int) uint8 {
            return call2<uint8>(so::fn.SDL_EventState, type, state);
        }

        inline SDL_RegisterEvents(numevents int) uint32 {
            return call1<uint32>(so::fn.SDL_RegisterEvents, numevents);
        }

        // SDL_render.h

        inline SDL_GetNumRenderDrivers() int {
            return call<int>(so::fn.SDL_GetNumRenderDrivers);
        }

        inline SDL_GetRenderDriverInfo(index int, info. SDL_RendererInfo) int {
            return call2<int>(so::fn.SDL_GetRenderDriverInfo, index, info);
        }

        inline SDL_CreateRenderer(window+ SDL_Window, index int, flags uint32) +SDL_Renderer {
            return call3<void>(so::fn.SDL_CreateRenderer, window, index, flags);
        }

        inline SDL_DestroyRenderer(renderer+ SDL_Renderer) {
            call1<void>(so::fn.SDL_DestroyRenderer, renderer);
        }

        inline SDL_GetRenderer(window+ SDL_Window) +SDL_Renderer {
            return call1<void>(so::fn.SDL_GetRenderer, window);
        }

        inline SDL_GetRendererInfo(window+ SDL_Window, info. SDL_RendererInfo) int {
            return call2<int>(so::fn.SDL_GetRendererInfo, window, info);
        }

        inline SDL_CreateTexture(renderer+ SDL_Renderer, format uint32, access int, w int, h int) +SDL_Texture {
            return call5<void>(so::fn.SDL_CreateTexture, renderer, format, access, w, h);
        }

        inline SDL_CreateTextureFromSurface(renderer+ SDL_Renderer, surface. SDL_Surface) +SDL_Texture {
            return call2<void>(so::fn.SDL_CreateTextureFromSurface, renderer, surface);
        }

        inline SDL_DestroyTexture(texture+ SDL_Texture) {
            call1<void>(so::fn.SDL_DestroyTexture, texture);
        }

        inline SDL_QueryTexture(texture+ SDL_Texture, format. uint32, access. int, w. int, h. int) int {
            return call5<int>(so::fn.SDL_QueryTexture, texture, format, access, w, h);
        }

        inline SDL_SetTextureColorMod(texture+ SDL_Texture, r uint8, g uint8, b uint8) int {
            return call4<int>(so::fn.SDL_SetTextureColorMod, texture, r, g, b);
        }

        inline SDL_GetTextureColorMod(texture+ SDL_Texture, r. uint8, g. uint8, b. uint8) int {
            return call4<int>(so::fn.SDL_GetTextureColorMod, texture, r, g, b);
        }

        inline SDL_SetTextureAlphaMod(texture+ SDL_Texture, alpha uint8) int {
            return call2<int>(so::fn.SDL_SetTextureAlphaMod, texture, alpha);
        }

        inline SDL_GetTextureAlphaMod(texture+ SDL_Texture, alpha. uint8) int {
            return call2<int>(so::fn.SDL_GetTextureAlphaMod, texture, alpha);
        }

        inline SDL_SetTextureBlendMode(texture+ SDL_Texture, blendMode SDL_BlendMode) int {
            return call2<int>(so::fn.SDL_SetTextureBlendMode, texture, blendMode);
        }

        inline SDL_GetTextureBlendMode(texture+ SDL_Texture, blendMode. SDL_BlendMode) int {
            return call2<int>(so::fn.SDL_GetTextureBlendMode, texture, blendMode);
        }

        inline SDL_UpdateTexture(texture+ SDL_Texture, rect. SDL_Rect, pixels void, pitch int) int {
            return call4<int>(so::fn.SDL_UpdateTexture, texture, rect, pixels, pitch);
        }

        inline SDL_UpdateYUVTexture(texture+ SDL_Texture, rect. SDL_Rect,
            Yplane. uint8, Ypitch int,
            Uplane. uint8, Upitch int,
            Vplane. uint8, Vpitch int) int {
            return call8<int>(so::fn.SDL_UpdateYUVTexture, texture, rect, Yplane, Ypitch, Uplane, Upitch, Vplane, Vpitch);
        }

        inline SDL_LockTexture(texture+ SDL_Texture, rect. SDL_Rect, pixels+ void, pitch. int) int {
            return call4<int>(so::fn.SDL_LockTexture, texture, rect, pixels, pitch);
        }

        inline SDL_UnlockTexture(texture+ SDL_Texture) {
            call1<void>(so::fn.SDL_UnlockTexture, texture);
        }

        inline SDL_RenderTargetSupported(renderer+ SDL_Renderer) SDL_bool {
            return call1<SDL_bool>(so::fn.SDL_RenderTargetSupported, renderer);
        }

        inline SDL_SetRenderTarget(renderer+ SDL_Renderer, texture+ SDL_Texture) int {
            return call2<int>(so::fn.SDL_SetRenderTarget, renderer, texture);
        }

        inline SDL_GetRenderTarget(renderer+ SDL_Renderer) +SDL_Texture {
            return call1<void>(so::fn.SDL_GetRenderTarget, renderer);
        }

        inline SDL_RenderSetLogicalSize(renderer+ SDL_Renderer, w int, h int) int {
            return call3<int>(so::fn.SDL_RenderSetLogicalSize, renderer, w, h);
        }

        inline SDL_RenderGetLogicalSize(renderer+ SDL_Renderer, w. int, h. int) {
            call3<void>(so::fn.SDL_RenderGetLogicalSize, renderer, w, h);
        }

        inline SDL_RenderSetIntegerScale(renderer+ SDL_Renderer, enable SDL_bool) int {
            return call2<int>(so::fn.SDL_RenderSetIntegerScale, renderer, enable);
        }

        inline SDL_RenderGetIntegerScale(renderer+ SDL_Renderer) SDL_bool {
            return call1<SDL_bool>(so::fn.SDL_RenderGetIntegerScale, renderer);
        }

        inline SDL_RenderSetViewport(renderer+ SDL_Renderer, rect. SDL_Rect) int {
            return call2<int>(so::fn.SDL_RenderSetViewport, renderer, rect);
        }

        inline SDL_RenderGetViewport(renderer+ SDL_Renderer, rect. SDL_Rect) {
            call2<void>(so::fn.SDL_RenderGetViewport, renderer, rect);
        }

        inline SDL_RenderSetClipRect(renderer+ SDL_Renderer, rect. SDL_Rect) int {
            return call2<int>(so::fn.SDL_RenderSetClipRect, renderer, rect);
        }

        inline SDL_RenderGetClipRect(renderer+ SDL_Renderer, rect. SDL_Rect) {
            call2<void>(so::fn.SDL_RenderGetClipRect, renderer, rect);
        }

        inline SDL_RenderIsClipEnabled(renderer+ SDL_Renderer) SDL_bool {
            return call1<SDL_bool>(so::fn.SDL_RenderIsClipEnabled, renderer);
        }

        inline SDL_RenderSetScale(renderer+ SDL_Renderer, scaleX float, scaleY float) int {
            return call_rff<int>(so::fn.SDL_RenderSetScale, renderer, scaleX, scaleY);
        }

        inline SDL_RenderGetScale(renderer+ SDL_Renderer, scaleX. float, scaleY. float) {
            call3<void>(so::fn.SDL_RenderGetScale, renderer, scaleX, scaleY);
        }

        inline SDL_SetRenderDrawColor(renderer+ SDL_Renderer, r uint8, g uint8, b uint8, a uint8) int {
            return call5<int>(so::fn.SDL_SetRenderDrawColor, renderer, r, g, b, a);
        }

        inline SDL_GetRenderDrawColor(renderer+ SDL_Renderer, r. uint8, g. uint8, b. uint8, a. uint8) int {
            return call5<int>(so::fn.SDL_GetRenderDrawColor, renderer, r, g, b, a);
        }

        inline SDL_SetRenderDrawBlendMode(renderer+ SDL_Renderer, blendMode SDL_BlendMode) int {
            return call2<int>(so::fn.SDL_SetRenderDrawBlendMode, renderer, blendMode);
        }

        inline SDL_GetRenderDrawBlendMode(renderer+ SDL_Renderer, blendMode. SDL_BlendMode) int {
            return call2<int>(so::fn.SDL_GetRenderDrawBlendMode, renderer, blendMode);
        }

        inline SDL_RenderClear(renderer+ SDL_Renderer) int {
            return call1<int>(so::fn.SDL_RenderClear, renderer);
        }

        inline SDL_RenderDrawPoint(renderer+ SDL_Renderer, x int, y int) int {
            return call3<int>(so::fn.SDL_RenderDrawPoint, renderer, x, y);
        }

        inline SDL_RenderDrawPoints(renderer+ SDL_Renderer, points. SDL_Point, count int) int {
            return call3<int>(so::fn.SDL_RenderDrawPoints, renderer, points, count);
        }

        inline SDL_RenderDrawLine(renderer+ SDL_Renderer, x1 int, y1 int, x2 int, y2 int) int {
            return call5<int>(so::fn.SDL_RenderDrawLine, renderer, x1, y1, x2, y2);
        }

        inline SDL_RenderDrawLines(renderer+ SDL_Renderer, points. SDL_Point, count int) int {
            return call3<int>(so::fn.SDL_RenderDrawLines, renderer, points, count);
        }

        inline SDL_RenderDrawRect(renderer+ SDL_Renderer, rect. SDL_Rect) int {
            return call2<int>(so::fn.SDL_RenderDrawRect, renderer, rect);
        }

        inline SDL_RenderDrawRects(renderer+ SDL_Renderer, rects. SDL_Rect, count int) int {
            return call3<int>(so::fn.SDL_RenderDrawRects, renderer, rects, count);
        }

        inline SDL_RenderFillRect(renderer+ SDL_Renderer, rect. SDL_Rect) int {
            return call2<int>(so::fn.SDL_RenderFillRect, renderer, rect);
        }

        inline SDL_RenderFillRects(renderer+ SDL_Renderer, rects. SDL_Rect, count int) int {
            return call3<int>(so::fn.SDL_RenderFillRects, renderer, rects, count);
        }

        inline SDL_RenderCopy(renderer+ SDL_Renderer, texture+ SDL_Texture, srcrect. SDL_Rect, dstrect. SDL_Rect) int {
            return call4<int>(so::fn.SDL_RenderCopy, renderer, texture, srcrect, dstrect);
        }

        inline SDL_RenderCopyEx(renderer+ SDL_Renderer,
            texture+ SDL_Texture,
            srcrect. SDL_Rect,
            dstrect. SDL_Rect,
            angle double,
            center. SDL_Point,
            flip SDL_RendererFlip) int {
            return call_rrrrdrr<int>(so::fn.SDL_RenderCopyEx, renderer, texture, srcrect, dstrect, angle, center, flip);
        }

        inline SDL_RenderReadPixels(renderer+ SDL_Renderer, rect. SDL_Rect, format uint32, pixels void, pitch int) int {
            return call5<int>(so::fn.SDL_RenderReadPixels, renderer, rect, format, pixels, pitch);
        }

        inline SDL_RenderPresent(renderer+ SDL_Renderer) {
            call1<void>(so::fn.SDL_RenderPresent, renderer);
        }

        // SDL_pixels.h

        inline SDL_GetPixelFormatName(format uint32) .char {
            return call1<char*>(so::fn.SDL_GetPixelFormatName, format);
        }

        inline SDL_PixelFormatEnumToMasks(format uint32, bpp. int, Rmask. uint32, Gmask. uint32, Bmask. uint32, Amask. uint32) SDL_bool {
            return call6<SDL_bool>(so::fn.SDL_PixelFormatEnumToMasks, format, bpp, Rmask, Gmask, Bmask, Amask);
        }

        inline SDL_MasksToPixelFormatEnum(bpp int, Rmask uint32, Gmask uint32, Bmask uint32, Amask uint32) uint32 {
            return call5<uint32>(so::fn.SDL_MasksToPixelFormatEnum, bpp, Rmask, Gmask, Bmask, Amask);
        }

        inline SDL_AllocFormat(pixel_format uint32) .SDL_PixelFormat {
            return call1<void>(so::fn.SDL_AllocFormat, pixel_format);
        }

        inline SDL_FreeFormat(format. SDL_PixelFormat) {
            call1<void>(so::fn.SDL_FreeFormat, format);
        }

        inline SDL_AllocPalette(ncolors int) .SDL_Palette {
            return call1<void>(so::fn.SDL_AllocPalette, ncolors);
        }

        inline SDL_SetPixelFormatPalette(format. SDL_PixelFormat, palette. SDL_Palette) int {
            return call2<int>(so::fn.SDL_SetPixelFormatPalette, format, palette);
        }

        inline SDL_SetPaletteColors(palette. SDL_Palette, colors. SDL_Color, firstcolor int, ncolors int) int {
            return call4<int>(so::fn.SDL_SetPaletteColors, palette, colors, firstcolor, ncolors);
        }

        inline SDL_FreePalette(palette. SDL_Palette) {
            call1<void>(so::fn.SDL_FreePalette, palette);
        }

        inline SDL_MapRGB(format. SDL_PixelFormat, r uint8, g uint8, b uint8) uint32 {
            return call4<uint32>(so::fn.SDL_MapRGB, format, r, g, b);
        }

        inline SDL_MapRGBA(format. SDL_PixelFormat, r uint8, g uint8, b uint8, a uint8) uint32 {
            return call4<uint32>(so::fn.SDL_MapRGBA, format, r, g, b, a);
        }

        inline SDL_GetRGB(pixel uint32, format. SDL_PixelFormat, r. uint8, g. uint8, b. uint8) {
            call5<void>(so::fn.SDL_GetRGB, pixel, format, r, g, b);
        }

        inline SDL_GetRGBA(pixel uint32, format. SDL_PixelFormat, r. uint8, g. uint8, b. uint8, a. uint8) {
            call6<void>(so::fn.SDL_GetRGBA, pixel, format, r, g, b, a);
        }

        inline SDL_CalculateGammaRamp(gamma float, ramp. uint16) {
            call_fr<void>(so::fn.SDL_CalculateGammaRamp, gamma, ramp);
        }

        // SDL_surface.h

        inline SDL_CreateRGBSurface(flags uint32, width int, height int, depth int, Rmask uint32, Gmask uint32, Bmask uint32, Amask uint32) .SDL_Surface {
            return call8<void>(so::fn.SDL_CreateRGBSurface, flags, width, height, depth, Rmask, Gmask, Bmask, Amask);
        }

        inline SDL_CreateRGBSurfaceWithFormat(flags uint32, width int, height int, depth int, format uint32) .SDL_Surface {
            return call5<void>(so::fn.SDL_CreateRGBSurfaceWithFormat, flags, width, height, depth, format);
        }

        inline SDL_CreateRGBSurfaceFrom(pixels void, width int, height int, depth int, pitch int, Rmask uint32, Gmask uint32, Bmask uint32, Amask uint32) .SDL_Surface {
            return call9<void>(so::fn.SDL_CreateRGBSurfaceFrom, pixels, width, height, depth, pitch, Rmask, Gmask, Bmask, Amask);
        }

        inline SDL_CreateRGBSurfaceWithFormatFrom(pixels void, width int, height int, depth int, pitch int, format uint32) .SDL_Surface {
            return call6<void>(so::fn.SDL_CreateRGBSurfaceWithFormatFrom, pixels, width, height, depth, pitch, format);
        }

        inline SDL_FreeSurface(surface. SDL_Surface) {
            call1<void>(so::fn.SDL_FreeSurface, surface);
        }

        inline SDL_SetSurfacePalette(surface. SDL_Surface, palette. SDL_Palette) int {
            return call2<int>(so::fn.SDL_SetSurfacePalette, surface, palette);
        }

        inline SDL_LockSurface(surface. SDL_Surface) int {
            return call1<int>(so::fn.SDL_LockSurface, surface);
        }

        inline SDL_UnlockSurface(surface. SDL_Surface) {
            call1<void>(so::fn.SDL_UnlockSurface, surface);
        }

        inline SDL_SetSurfaceRLE(surface. SDL_Surface, flag int) int {
            return call2<int>(so::fn.SDL_SetSurfaceRLE, surface, flag);
        }

        inline SDL_SetColorKey(surface. SDL_Surface, flag int, key uint32) int {
            return call3<int>(so::fn.SDL_SetColorKey, surface, flag, key);
        }

        inline SDL_GetColorKey(surface. SDL_Surface, key. uint32) int {
            return call2<int>(so::fn.SDL_GetColorKey, surface, key);
        }

        inline SDL_SetSurfaceColorMod(surface. SDL_Surface, r uint8, g uint8, b uint8) int {
            return call4<int>(so::fn.SDL_SetSurfaceColorMod, surface, r, g, b);
        }

        inline SDL_GetSurfaceColorMod(surface. SDL_Surface, r. uint8, g. uint8, b. uint8) int {
            return call4<int>(so::fn.SDL_GetSurfaceColorMod, surface, r, g, b);
        }

        inline SDL_SetSurfaceAlphaMod(surface. SDL_Surface, alpha uint8) int {
            return call2<int>(so::fn.SDL_SetSurfaceAlphaMod, surface, alpha);
        }

        inline SDL_GetSurfaceAlphaMod(surface. SDL_Surface, alpha. uint8) int {
            return call2<int>(so::fn.SDL_GetSurfaceAlphaMod, surface, alpha);
        }

        inline SDL_SetSurfaceBlendMode(surface. SDL_Surface, blendMode SDL_BlendMode) int {
            return call2<int>(so::fn.SDL_SetSurfaceBlendMode, surface, blendMode);
        }

        inline SDL_GetSurfaceBlendMode(surface. SDL_Surface, blendMode. SDL_BlendMode) int {
            return call2<int>(so::fn.SDL_GetSurfaceBlendMode, surface, blendMode);
        }

        inline SDL_SetClipRect(surface. SDL_Surface, rect. SDL_Rect) SDL_bool {
            return call2<SDL_bool>(so::fn.SDL_SetClipRect, surface, rect);
        }

        inline SDL_GetClipRect(surface. SDL_Surface, rect. SDL_Rect) {
            call2<void>(so::fn.SDL_GetClipRect, surface, rect);
        }

        inline SDL_ConvertSurface(src. SDL_Surface, fmt. SDL_PixelFormat, flags uint32) .SDL_Surface {
            return call3<void>(so::fn.SDL_ConvertSurface, src, fmt, flags);
        }

        inline SDL_ConvertSurfaceFormat(src. SDL_Surface, pixel_format uint32, flags uint32) .SDL_Surface {
            return call3<void>(so::fn.SDL_ConvertSurfaceFormat, src, pixel_format, flags);
        }

        inline SDL_ConvertPixels(width int, height int, src_format uint32, src void, src_pitch int, dst_format uint32, dst void, dst_pitch int) int {
            return call8<int>(so::fn.SDL_ConvertPixels, width, height, src_format, src, src_pitch, dst_format, dst, dst_pitch);
        }

        inline SDL_FillRect(dst. SDL_Surface, rect. SDL_Rect, color uint32) int {
            return call3<int>(so::fn.SDL_FillRect, dst, rect, color);
        }

        inline SDL_FillRects(dst. SDL_Surface, rects. SDL_Rect, count int, color uint32) int {
            return call4<int>(so::fn.SDL_FillRects, dst, rects, count, color);
        }

        inline SDL_BlitSurface(src. SDL_Surface, srcrect. SDL_Rect, dst. SDL_Surface, dstrect. SDL_Rect) int  {
            return call4<int>(so::fn.SDL_UpperBlit, src, srcrect, dst, dstrect);
        }

        inline SDL_UpperBlit(src. SDL_Surface, srcrect. SDL_Rect, dst. SDL_Surface, dstrect. SDL_Rect) int  {
            return call4<int>(so::fn.SDL_UpperBlit, src, srcrect, dst, dstrect);
        }

        inline SDL_LowerBlit(src. SDL_Surface, srcrect. SDL_Rect, dst. SDL_Surface, dstrect. SDL_Rect) int {
            return call4<int>(so::fn.SDL_LowerBlit, src, srcrect, dst, dstrect);
        }

        inline SDL_SoftStretch(src. SDL_Surface, srcrect. SDL_Rect, dst. SDL_Surface, dstrect. SDL_Rect) int {
            return call4<int>(so::fn.SDL_SoftStretch, src, srcrect, dst, dstrect);
        }

        inline SDL_BlitScaled(src. SDL_Surface, srcrect. SDL_Rect, dst. SDL_Surface, dstrect. SDL_Rect) int {
            return call4<int>(so::fn.SDL_UpperBlitScaled, src, srcrect, dst, dstrect);
        }

        inline SDL_UpperBlitScaled(src. SDL_Surface, srcrect. SDL_Rect, dst. SDL_Surface, dstrect. SDL_Rect) int {
            return call4<int>(so::fn.SDL_UpperBlitScaled, src, srcrect, dst, dstrect);
        }

        inline SDL_LowerBlitScaled(src. SDL_Surface, srcrect. SDL_Rect, dst. SDL_Surface, dstrect. SDL_Rect) int {
            return call4<int>(so::fn.SDL_LowerBlitScaled, src, srcrect, dst, dstrect);
        }

    }

}
